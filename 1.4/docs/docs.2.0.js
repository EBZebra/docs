var docs = [{"key":"api-EMDKManager-EMDKListener","name":"EMDKManager.EMDKListener","md":"#EMDKManager.EMDKListener\nThis is the interface for the callback to notify the opening and closing status of the EMDK. On a successful opening, the EMDKManager object will be returned. An interface for notifying clients when they the EMDKManager is ready to use or closed abruptly.\n\n**Example Usage:**\n\n\t:::java\n\tpublic class MainActivity extends Activity implements EMDKListener\n\n\t.. .. ..\n\n\tEMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Version:**\n2.0\n\n##Public Methods\n###onClosed()\nCalled to notify the client that this EMDKManager object has been abruptly closed. The clients must call to call [EMDKManager.release()](#api-EMDKManager?release()) to free all the resources used by EMDKManager even after onClosed(). Notifies user upon a abrupt closing of EMDKManager.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onClosed()\n\t{\n\n\t}\n\n\n**Returns:**\nvoid\n\n###onOpened(EMDKManager emdkManager)\nCalled to notify the client when the EMDKManager object has been opened and its ready to use.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkManager)\n\t{\n\n\t}\n\n\n**Parameters:**\n\n**emdkManager**\n\n**Returns:**\nvoid\n"},{"key":"api-EMDKManager","name":"EMDKManager","md":"#EMDKManager\n\nThe EMDKManager class is the key class in Android EMDK. This class provides access to different classes for the supported features. Clients should call EMDKManager.getEMDKManager(Context, EMDKManager.EMDKListener), to get the EMDKManager object. Each application implements EMDKListener interface. The EMDKManager object will be returned on successful opening through the EMDKListener callback.\n\n**Example Usage:**\n\n\t:::java\n\tEMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Version:**\n\n2.0\n\n##Public Methods\n###getEMDKManager(Context context, EMDKManager.EMDKListener emdkListener)\nThis is static method and it is the key function to get the EMDKManager object. Clients must implement [EMDKManager.EMDKListener](#api-EMDKManager-EMDKListener) to get notified of the EMDK manager status and to get the EMDKManager object.\n\n**Example Usage:**\n\n\t:::java\n\tEMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), emdkListener);\n\n\n**Parameters:**\n\n**context** - The application context should be provided by the user.\n**emdkListener** - The EMDK Listener for listener callbacks.\n\n**Returns:**\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###getInstance(EMDKManager.FEATURE_TYPE featureType)\nThis method returns an object instance which has derived from EMDKBase. Based on the type given, the object needs to be type-casted before used. Calling this method [EMDKManager.getInstance(FEATURE_TYPE)](#api-EMDKManager?getInstance(EMDKManager.FEATURE_TYPE featureType)) before EMDKManager opened will return null.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\tVersionManager versionManager = (VersionManager)emdkmanager.getInstance(FEATURE_TYPE.VERSION);\n\t}\n\n\n**Parameters:**\n\n**featureType** - The [EMDKManager.FEATURE_TYPE](#api-EMDKManager?FEATURE_TYPE) the object to be created.\n\n**Returns:**\ncom.symbol.emdk.EMDKBase - Object derived from EMDKBase to be type-casted to the appropriate type. Currently [ProfileManager](#api-ProfileManager) and [VersionManager](#api-VersionManager) are returned based on the EMDKManager.FEATURE_TYPE given in.\n\n###release()\nThis method releases all the resources constructed by EMDKManager. EMDKManager can't be used after this call. The clients must call this method before exiting the application.\n\n**Example Usage:**\n\n\t:::java\n\temdkManager.release();\n\n\n**Returns:**\nvoid\n\n###release(EMDKManager.FEATURE_TYPE featureType)\nThis method releases resources of a given manager type. Instance variable is not required as multiple instances are not allowed by design.\n\n**Example Usage:**\n\n\t:::java\n\temdkManager.release(EMDKManager.FEATURE_TYPE.PROFILE);\n\n\n**Parameters:**\n\n**featureType** - Type of [EMDKManager.FEATURE_TYPE](#api-EMDKManager?FEATURE_TYPE) to be released. Only the given feature related manager will be cleared if it has been constructed.\n\n**Returns:**\n\nvoid\n\n##Public Enums\n###FEATURE_TYPE\nThis lists all the features exposed by the EMDK.\n\n**Example Usage:**\n\n\t:::java\n\tFEATURE_TYPE.PROFILE\n\n\n**Values:**\n\n**PROFILE** - EMDK feature type profile\n**VERSION** - EMDK feature type version\n\n"},{"key":"api-EMDKResults","name":"EMDKResults","md":"#EMDKResults\nClass for holding result data.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileConfig profileConfigObj = new ProfileConfig();\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\tEMDKResults results = profileManager.processProfile(\"Profile Name\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t}\n\n\n**Version:**\n2.0\n\n##Public Methods\n###getStatusDocument()\nGets status results from process profile as xml document.\n\n**Example Usage:**\n\n\t:::java\n\tDocument document = results.getStatusDocument();\n\n\n**Returns:**\norg.w3c.dom.Document - XML document.\n\n###getStatusString()\nGets status results from process profile as xml string.\n\n**Example Usage:**\n\n\t:::java\n\tString xml = results.getStatusString();\n\n\n**Returns:**\njava.lang.String - XML text.\n\n##Public Fields\n###statusCode\nGets status code result from process profile as enum value of type [EMDKResults.STATUS_CODE](#api-EMDKResults?STATUS_CODE)\t.\n\n**Example Usage:**\n\n\t:::java\n\tSTATUS_CODE statusCode = results.statusCode;\n\n\n**Type:**\ncom.symbol.emdk.[EMDKResults.STATUS_CODE](#api-EMDKResults?STATUS_CODE)\n\n##Public Enums\n###STATUS_CODE\nDefines all the status codes the library returns.\n\n**Example Usage:**\n\n\t:::java\n\tresults.statusCode.SUCCESS;\n\n\n**Values:**\n\n* **SUCCESS** - Process profile was a success.\n* **FAILURE** - Process profile was a failure.\n* **UNKNOWN** - Process profile had mixed results.\n* **NULL_POINTER** - Process profile was a had a null value.\n* **EMPTY_PROFILENAME** - Profile name passed Process profile was empty.\n* **EMDK_NOT_OPENED** - EMDK is not opened\n"},{"key":"api-ProfileConfig-ActivitySelection-ActivityElement","name":"ProfileConfig.ActivitySelection.ActivityElement","md":"#ProfileConfig.ActivitySelection.ActivityElement\nGets and Sets application's package name and its activities to the profile [ProfileConfig.ActivitySelection.ActivityElement](#api-ProfileConfig-ActivitySelection-ActivityElement).\n\n**Example Usage:**\n\n\t:::java\n\tArrayList<ActivityElement> activities = profileConfig.activitySelection.activities;\n\n\n**Version:**\n\n2.0\n\n##Constructors\n\n###ProfileConfig.ActivitySelection.ActivityElement**(String packageName, java.lang.String[] activities)\n\n**Parameters:**\n\n* packageName\n* activities\n\n##Public Fields\n\n###packageName\n\n**Type:**\n\njava.lang.String\n\n"},{"key":"api-ProfileConfig-ActivitySelection","name":"ProfileConfig.ActivitySelection","md":"#ProfileConfig.ActivitySelection\nClass for dealing with ActivitySelection of profile data ProfileConfig.activitySelection()\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection;\n\n\n**Version:**\n\n2.0\n\n##Constructors\n###ProfileConfig.ActivitySelection()\n\n##Public Fields\n###activities\nGets and Sets activities to the profile ProfileConfig.ActivitySelection.activities.\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection\n\n\n**Type:**\n\njava.util.ArrayList&lt;com.symbol.emdk.ProfileConfig.ActivitySelection.ActivityElement&gt;\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar\nHolds Codabar configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCodabar codabar = profileConfig.dataCapture.barcode.decoderParams.codabar;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###clsi_editing\nEnable this parameter to strip the start and stop characters and insert a space after the first, fifth, and tenth characters of a 14-character Codabar symbol. Enable this feature if the host system requires this data format (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.clsi_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 6).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = codabar.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = codabar.length2;\n\n\n**Type:**\n\nint\n\n###notis_editing\nEnable this parameter to strip the start and stop characters from a decoded Codabar symbol. Enable this feature if the host system requires this data format (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.notis_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcodabar.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code11","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code11\nHolds Code 11 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode11 code11 = profileConfig.dataCapture.barcode.decoderParams.code11;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUse to set decode lengths (default - 4).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code11.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code11.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Code 11 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###verify_check_digit\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code. Use enum [ProfileConfig.VERIFY_CHECK_DIGIT](#api-ProfileConfig?VERIFY_CHECK_DIGIT).\n\n**Example Usage:**\n\n\t:::java\n\tcode11.verify_check_digit = VERIFY_CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.VERIFY_CHECK_DIGIT](#api-ProfileConfig?VERIFY_CHECK_DIGIT)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code128","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code128\nHolds Code128 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode128 code128 = profileConfig.dataCapture.barcode.decoderParams.code128;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_isbt_table\nThe ISBT specification includes a table that lists several types of ISBT bar codes that are commonly used in pairs. If ISBT128 Concat Mode is set, enable Check ISBT T able to concatenate only those pairs found in this table. Other types of ISBT codes are not concatenated (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.check_isbt_table = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###enable_ean128\nUse enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.enable_ean128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###enable_plain\nFlag to enable other 128 sub types (besides GS1-128 and ISBT -128). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.enable_plain = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###isbt128_concat_mode\nSelect an option for concatenating pairs of ISBT code types. Use enum [ProfileConfig.ISBT128_CONTACT_MODE](#api-ProfileConfig?ISBT128_CONTACT_MODE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.isbt128_concat_mode = ISBT128_CONTACT_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ISBT128_CONTACT_MODE](#api-ProfileConfig?ISBT128_CONTACT_MODE)\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code128.length1;\n\n\n\n**Type:**\n\nint\n\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code128.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nThe scanner of fers four levels of decode security for Code 128 bar codes. Select increasing levels of security for decreasing levels of bar code quality. There is an inverse relationship between security and scanner aggressiveness, so choose only that level of security necessary for any given application. Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tcode128.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code39","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code39\nHolds Code39 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode39 code39 = profileConfig.dataCapture.barcode.decoderParams.code39;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n###convert_to_code32\nCode 32 is a variant of Code 39 used by the Italian pharmaceutical industry (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.convert_to_code32 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###full_ascii\nCode 39 Full ASCII is a variant of Code 39 that pairs characters to encode the full ASCII character set (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.full_ascii = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code39.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths 4 (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code39.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Code 39 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_code32_prefix\nScan the appropriate bar code to enable or disable adding the prefix character \"A\" to all Code 32 bar codes (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.report_code32_prefix = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nOptions: Security level 0 , Security Level 1 , Security Level 2 and Security Level 3 (default - Security level 1). Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n###verify_check_digit\nEnable this feature to check the integrity of all Code 39 symbols to verify that the data complies with a specified check digit algorithm. The digital scanner decodes only those Code 39 symbols that include a modulo 43 check digit. Enable this feature only if the Code 39 symbols contain a modulo 43 check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode39.verify_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Code93","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Code93\nHolds Code93 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tCode93 code93 = profileConfig.dataCapture.barcode.decoderParams.code93;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUse to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = code93.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = code93.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tcode93.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB\nHolds Composite AB configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tComposite_AB compositeAB = profileConfig.dataCapture.barcode.decoderParams.composite_AB;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###ucc_link_mode\nGets and Sets UCC Link Mode using [ProfileConfig.UCC_LINK_MODE](#api-ProfileConfig?UCC_LINK_MODE) enum;\n\n**Example Usage:**\n\n\t:::java\n\tcompositeAB.ucc_link_mode = UCC_LINK_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.UCC_LINK_MODE](#api-ProfileConfig?UCC_LINK_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5\nHolds Discrete 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tDiscrete_2of5 discrete_2of5 = profileConfig.dataCapture.barcode.decoderParams.discrete_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUsed to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = discrete_2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths (default - 14).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = discrete_2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdiscrete_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5\nHolds Interleaved 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tInterleaved_2of5 interleaved2of5 = profileConfig.dataCapture.barcode.decoderParams.interleaved_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_digit\nThe check digit type to verify. Use enum [ProfileConfig.CHECK_DIGIT_TYPE](#api-ProfileConfig?CHECK_DIGIT_TYPE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.check_digit = CHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT_TYPE](#api-ProfileConfig?CHECK_DIGIT_TYPE)\n\n###convert_itf14_to_ean13\nConvert 14-character Interleaved 2 of 5 bar codes to EAN-13, and transmit as EAN-13. The Interleaved 2 of 5 bar code must be enabled and must have a leading zero and a valid EAN-13 check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.convert_itf14_to_ean13 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###length1\nUse to set decode lengths (default - 14).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = interleaved2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 10).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = interleaved2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Interleaved 2 of 5 data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###security_level\nSpecifies security level Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\tinterleaved2of5.security_level = SECURITY_LEVEL.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5\nHolds Matrix 2 of 5 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tMatrix_2of5 matrix2of5 = profileConfig.dataCapture.barcode.decoderParams.matrix_2of5;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###length1\nUsed to set decode lengths (default - 10).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = matrix2of5.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUsed to set decode lengths (default - 0).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = matrix2of5.length2;\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit Matrix 2 of 5 data with or without the check digit(default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###verify_check_digit\nEnable this feature to check the integrity of all Matrix 2 of 5 symbols to verify that the data complies with a specified check digit algorithm (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmatrix2of5.verify_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.MSI","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.MSI\nHolds Codabar configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tMSI msi = profileConfig.dataCapture.barcode.decoderParams.msi;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###check_digit\nWith MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional. Use enum [ProfileConfig.CHECK_DIGIT](#api-ProfileConfig?CHECK_DIGIT).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.check_digit = CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT](#api-ProfileConfig?CHECK_DIGIT)\n\n###check_digit_scheme\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit. Use enum [ProfileConfig.CHECK_DIGIT_SCHEME](#api-ProfileConfig?CHECK_DIGIT_SCHEME).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.check_digit_scheme = CHECK_DIGIT_SCHEME.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CHECK_DIGIT_SCHEME](#api-ProfileConfig?CHECK_DIGIT_SCHEME)\n\n###length1\nUse to set decode lengths (default - 4).\n\n**Example Usage:**\n\n\t:::java\n\tint length1 = msi.length1;\n\n\n**Type:**\n\nint\n\n###length2\nUse to set decode lengths (default - 55).\n\n**Example Usage:**\n\n\t:::java\n\tint length2 = msi.length2\n\n\n**Type:**\n\nint\n\n###redundancy\nSets the reader to read the bar code twice before accepting data (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###report_check_digit\nTransmit MSI data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsi.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal\nHolds UK Postal configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUK_Postal ukPostal = profileConfig.dataCapture.barcode.decoderParams.uk_Postal;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###report_check_digit\nTransmit UK Postal data with or without the check digit (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tukPostal.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA\nHolds UPCA configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCA upca = profileConfig.dataCapture.barcode.decoderParams.upca;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\n\t:::java\n\tupca.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - enabled) . Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupca.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0\nHolds UPCE0 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCE0 upce0 = profileConfig.dataCapture.barcode.decoderParams.upce0;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###convert_to_upca\nEnable to convert UPCE0 (zero suppressed) decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is af fected by UPC-A programming selections. Disable to transmit UPCE0 decoded data as UPCE0 data, without conversion (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce0.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1","name":"ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1\nHolds UPCE1 configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUPCE1 upce1 = profileConfig.dataCapture.barcode.decoderParams.upce1;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###convert_to_upca\nEnable this to convert UPCE1 decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is af fected by UPC-A programming selections. Disable this to transmit UPCE1 decoded data as UPCE1 data, without conversion (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce1.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###preamble\nPreamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system. Use enum [ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE).\n\n**Example Usage:**\n\t:::java\n\tupce1.preamble = PREAMBLE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PREAMBLE](#api-ProfileConfig?PREAMBLE)\n\n###report_check_digit\nThe check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option (default - disabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupce1.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-DecoderParams","name":"ProfileConfig.DataCapture.Barcode.DecoderParams","md":"#ProfileConfig.DataCapture.Barcode.DecoderParams\nHolds Decoder configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tDecoderParams decoderParams = profileConfig.dataCapture.barcode.decoderParams;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###codabar\nConfigures the Codabar Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.codabar.clsi_editing = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar)\n\n###code11\nConfigures the Code11 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code11.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11)\n\n###code128\nConfigures the Code128 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code128.enable_ean128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128)\n\n###code39\nConfigures the Code39 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39).\n\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code39.full_ascii = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39)\n\n###code93\nConfigures the Code93 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.code93.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93)\n\n###composite_AB\nConfigures the Composite AB Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.composite_AB.ucc_link_mode = UCC_LINK_MODE.ALWAYS_LINKED;\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB)\n\n###discrete_2of5\nConfigures the Discrete_2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.discrete_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5)\n\n###interleaved_2of5\nConfigures the Interleaved 2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.interleaved_2of5.check_digit = CHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5)\n\n###matrix_2of5\nConfigures the Matrix 2of5 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.matrix_2of5.redundancy = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5)\n\n###msi\nConfigures the MSI Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.msi.check_digit = CHECK_DIGIT.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI)\n\n###uk_Postal\nConfigures the UK_Postal Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.uk_Postal.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal)\n\n###upca\nConfigures the UPCA Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upca.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA)\n\n###upce0\nConfigures the UPCE0 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upce0.report_check_digit = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0)\n\n###upce1\nConfigures the UPCE1 Symbology object [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1).\n\n**Example Usage:**\n\n\t:::java\n\tdecoderParams.upce1.convert_to_upca = ENABLED_STATE.DEFAULT;\n\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-Decoders","name":"ProfileConfig.DataCapture.Barcode.Decoders","md":"#ProfileConfig.DataCapture.Barcode.Decoders\nThe Decoders class provides access to enable or disable decoder barcode symbologies.\n\n**Example Usage:**\n\n\t:::java\n\tDecoders decoders = barcode.decoders;\n\n\tdecoders.upca = ENABLED_STATE.TRUE;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###australian_postal\nSets the Enabled State of Decoder Australian Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.australian_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###aztec\nSets the Enabled State of Decoder Aztec. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.aztec = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###canadian_postal\nSets the Enabled State of Decoder Canadian Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.canadian_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###chinese_2of5\nSets the Enabled State of Decoder Chinese 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.chinese_2of5 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###codabar\nSets the Enabled State of Decoder Codabar. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.codabar = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code11\nSets the Enabled State of Decoder Code11. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code11 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code128\nSets the Enabled State of Decoder Code 128. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code128 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code39\nSets the Enabled State of Decoder Code 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code39 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###code93\nSets the Enabled State of Decoder Code 93. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.code93 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###composite_ab\nSets the Enabled State of Decoder Composite AB. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.composite_ab = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###composite_c\nSets the Enabled State of Decoder Composite C. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.composite_c = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###d2of5\nSets the Enabled State of Decoder Discrete 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.d2of5 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###datamatrix\nSets the Enabled State of Decoder Data Matrix. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.datamatrix = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###dutch_postal\nSets the Enabled State of Decoder Dutch Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.dutch_postal = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###ean13\nSets the Enabled State of Decoder EAN-13. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.ean13 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###ean8\nSets the Enabled State of Decoder EAN-8. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.ean8 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar\nSets the Enabled State of Decoder Interleaved 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar_exp\nSets the Enabled State of Decoder GS1 DataBar Expanded. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar_exp = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###gs1_databar_lim\nSets the Enabled State of Decoder GS1 DataBar Limited. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.gs1_databar_lim = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###i2of5\nUse enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.i2of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###japanese_postal\nSets the Enabled State of Decoder Japan Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.japanese_postal = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###korean_3of5\nSets the Enabled State of Decoder Korean 3 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.korean_3of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###matrix_2of5\nSets the Enabled State of Decoder Matrix 2 of 5. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.matrix_2of5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###maxicode\nSets the Enabled State of Decoder Maxicode. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.maxicode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###micropdf\nSets the Enabled State of Decoder Micro PDF. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.micropdf = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###microqr\nSets the Enabled State of Decoder Micro QR. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.microqr = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###msi\nSets the Enabled State of Decoder MSI. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.msi = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###pdf417\nSets the Enabled State of Decoder PDF417. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.pdf417 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###qrcode\nSets the Enabled State of Decoder QR Code. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.qrcode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###signature\nSets the Enabled State of Decoder Signature. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.signature = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###tlc39\nSets the Enabled State of Decoder TLC 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.tlc39 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###trioptic39\nSets the Enabled State of Decoder Trioptic 39. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.trioptic39 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###uk_postal\nSets the Enabled State of Decoder UK Postal. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.uk_postal = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upca\nSets the Enabled State of Decoder UPCA. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upca = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upce0\nSets the Enabled State of Decoder UPCE0. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upce0 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upce1\nSets the Enabled State of Decoder UPCE1. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.upce1 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###us4state\nSets the Enabled State of Decoder US4State. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.us4state = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###us4state_fics\nSets the Enabled State of Decoder US4State FICS. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.us4state_fics = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###usplanet\nSets the Enabled State of Decoder US Planet. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.usplanet = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###uspostnet\nSets the Enabled State of Decoder US Postnet. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.uspostnet = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###webcode\nSets the Enabled State of Decoder Web Code. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tdecoders.webcode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-ReaderParams","name":"ProfileConfig.DataCapture.Barcode.ReaderParams","md":"#ProfileConfig.DataCapture.Barcode.ReaderParams\nHolds reader configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tReaderParams readerParams = profileConfig.dataCapture.barcode.readerParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###beam_timer\nSets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely (default -15000).\n\n**Example Usage:**\n\n\t:::java\n\tint timer = readerParams.beam_timer;\n\n**Type:**\n\nint\n\n###illumination_mode\nTurns camera illumination on and off. This option is only available when camera is selected in the Barcode input Scanner selection option. Use enum [ProfileConfig.ILLUMINATION_MODE](#api-ProfileConfig?ILLUMINATION_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.illumination_mode = ILLUMINATION_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ILLUMINATION_MODE](#api-ProfileConfig?ILLUMINATION_MODE)\n\n###inverse_1d_mode\nThis parameter allows the user to select decoding on inverse 1D bar codes. Use enum [ProfileConfig.INVERSE_1D_MODE](#api-ProfileConfig?INVERSE_1D_MODE).\n\n**Example Usage:**\n\t\n\t:::java\n\treaderParams.inverse_1d_mode = INVERSE_1D_MODE.AUTO;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.INVERSE_1D_MODE](#api-ProfileConfig?INVERSE_1D_MODE)\n\n###lcd_mode\nEnables or disables LCD mode. LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones (imager only). Use enum [ProfileConfig.LCD_MODE](#api-ProfileConfig?LCD_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.lcd_mode = LCD_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.LCD_MODE](#api-ProfileConfig?LCD_MODE)\n\n###linear_security_level\nSets the number of times a bar code is read to confirm an accurate decode. Use enum [ProfileConfig.LINEAR_SECURITY_LEVEL](#api-ProfileConfig?LINEAR_SECURITY_LEVEL).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.linear_security_level = LINEAR_SECURITY_LEVEL.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.LINEAR_SECURITY_LEVEL](#api-ProfileConfig?LINEAR_SECURITY_LEVEL)\n\n###low_power_timeout\nTime in milliseconds of non-use before dropping to a low-power mode.\n\n**Example Usage:**\n\n\t:::java\n\tint timeout = readerParams.low_power_timeout;\n\n**Type:**\n\nint\n\n###picklist\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is targeted for decode. Use enum [ProfileConfig.PICK_LIST](#api-ProfileConfig?PICK_LIST).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.picklist = PICK_LIST.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.PICK_LIST](#api-ProfileConfig?PICK_LIST)\n\n###viewfinder_mode\nConfigures the Viewfinder modes supported for camera scanning. Use enum [ProfileConfig.VIEWFINDER_MODE](#api-ProfileConfig?VIEWFINDER_MODE).\n\n**Example Usage:**\n\n\t:::java\n\treaderParams.viewfinder_mode = VIEWFINDER_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.VIEWFINDER_MODE](#api-ProfileConfig?VIEWFINDER_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-ScanParams","name":"ProfileConfig.DataCapture.Barcode.ScanParams","md":"#ProfileConfig.DataCapture.Barcode.ScanParams\nHolds scanning configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tScanParams scanParams = profileConfig.dataCapture.barcode.scanParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###code_id_type\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol. Use enum [ProfileConfig.CODE_ID_TYPE](#api-ProfileConfig?CODE_ID_TYPE).\n\n**Example Usage:**\n\n\t:::java\n\tscanParams.code_id_type = CODE_ID_TYPE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.CODE_ID_TYPE](#api-ProfileConfig?CODE_ID_TYPE)\n\n###datacapture_led_id\nData Capture LED ID\n\n**Example Usage:**\n\n\t:::java\n\tint led = scanParams.datacapture_led_id;\n\n**Type:**\n\nint\n\n###decode_audio_feedback_uri\nSelect an audio tone to sound upon a good decode.\n\n**Example Usage:**\n\n\t:::java\n\tString audioFeedback = scanParams.decode_audio_feedback_uri;\n\n**Type:**\n\njava.lang.String\n\n###decode_haptic_feedback\nEnable the device to vibrate upon a good decode (default - enabled). Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tscanParams.decode_haptic_feedback = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###good_decode_led_timer\nTime for which Good Decode LED Notification Runs in milliseconds.\n\n**Example Usage:**\n\n\t:::java\n\tint ledTimer = scanParams.good_decode_led_timer;\n\n**Type:**\n\nint\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode-UpcEanParams","name":"ProfileConfig.DataCapture.Barcode.UpcEanParams","md":"#ProfileConfig.DataCapture.Barcode.UpcEanParams\nHolds Upc Ean Params configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tUpcEanParams upcEanParams = profileConfig.dataCapture.barcode.upcEanParams;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###bookland\nFlag to enable Bookland code decoding. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.bookland = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bookland_format\nSpecifies the bookland format to use. Use enum [ProfileConfig.BOOKLAND_FORMAT](#api-ProfileConfig?BOOKLAND_FORMAT).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.bookland_format = BOOKLAND_FORMAT.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.BOOKLAND_FORMAT](#api-ProfileConfig?BOOKLAND_FORMAT)\n\n###coupon\nEnables Coupon code decoding. Note that in order to successfully decode Coupon codes, all of the correct decoders must be enabled. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.coupon = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###coupon_report\nUsed to differentiate between old coupon (UPC/EAN and Code128) and new GS1 DataBar Coupons. NOTE: There is an Interim GS1 DataBar Coupon (UPC A and the GS1 DataBar), which is meant for smooth transition of adaption from old coupon format to new coupon format. If an interim coupon is presented to the scanner, it will read old or new portion of it, depending on the report mode setting. Use enum [ProfileConfig.COUPON_REPORT](#api-ProfileConfig?COUPON_REPORT).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.coupon_report = COUPON_REPORT.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.COUPON_REPORT](#api-ProfileConfig?COUPON_REPORT)\n\n###databar_to_upc_ean\nIf this is set it converts DataBar bar codes to UPC/EAN format. For this setting to work UPC/EAN symbologies must be enabled. A check in the checkbox indicates that the option is enabled. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.databar_to_upc_ean = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###linear_decode\nFlag to enable linear decode. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.linear_decode = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###random_weight_check_digit\nFlag to enable random weight check digit verification. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.random_weight_check_digit = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###retry_count\nRetry count for auto-discriminating for supplementals. Possible values are 2 to 20 inclusive. Note that this flag is only considered if Supplemental Mode - UPC EAN is set to one of the following values: Supplementals Auto, Supplementals Smart, Supplementals 378-379 , Supplementals 978-979, Supplementals 977 or Supplementals 414-419-434-439 (2 to 20, default 10).\n\n**Example Usage:**\n\n\t:::java\n\tint retry = upcEanParams.retry_count;\n\n**Type:**\n\nint\n\n###security_level\nThe scanner of fers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application. Use enum [ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL).\n\n**Example Usage:**\n\t\n\t:::java\n\tupcEanParams.security_level = SECURITY_LEVEL.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SECURITY_LEVEL](#api-ProfileConfig?SECURITY_LEVEL)\n\n###supplemental2\nFlag to enable length 2 supplementals. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental2 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###supplemental5\nFlag to enable length 5 supplementals. Use enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental5 = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###supplemental_mode\nThe supplemental mode. Use enum [ProfileConfig.SUPPLEMENTAL_MODE](#api-ProfileConfig?SUPPLEMENTAL_MODE).\n\n**Example Usage:**\n\n\t:::java\n\tupcEanParams.supplemental_mode = SUPPLEMENTAL_MODE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.SUPPLEMENTAL_MODE](#api-ProfileConfig?SUPPLEMENTAL_MODE)\n\n"},{"key":"api-ProfileConfig-DataCapture-Barcode","name":"ProfileConfig.DataCapture.Barcode","md":"#ProfileConfig.DataCapture.Barcode\nHolds Barcode configuration settings\n\n**Example Usage:**\n\n\t:::java\n\tBarcode barcode = profileConfig.dataCapture.barcode;\n\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###decoderParams\nGets and Sets DecoderParams configuration object [ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.decoderParams.upca.preamble = PREAMBLE.SYS_CHAR;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams)\n\n###decoders\nGets and Sets Decoders configuration object [ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.decoders.codabar = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders)\n\n###readerParams\nGets and Sets ReaderParams configuration object [ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.readerParams.illumination_mode = ILLUMINATION_MODE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams)\n\n###scanParams\nGets and Sets ScanParams configuration object [ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.ScanParams.decode_haptic_feedback = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams)\n\n###scannerSelection\nGets and Sets scanner selection [ProfileConfig.DEVICETYPES](#api-ProfileConfig?DEVICETYPES).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.scannerSelection = DEVICETYPES.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DEVICETYPES](#api-ProfileConfig?DEVICETYPES)\n\n###scanner_input_enabled\nGets and Sets scanner enabled state [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.scanner_input_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###upcEanParams\nGets and Sets UpcEanParams configuration object [ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams).\n\n**Example Usage:**\n\n\t:::java\n\tbarcode.upcEanParams.linear_decode = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting","name":"ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting","md":"#ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting\nHolds Basic Data Formatting configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tBasicDataFormatting basicDataFormatting = profileConfig.dataCapture.dataDelivery.intent.basicDataFormatting;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###bdf_enabled\nEnables or disables Basic Data Formatting (default - enabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\t\n\t:::java\n\tbasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_prefix\nAdd characters to the beginning of the data when sent.\n\n**Example Usage:**\n\t\n\t:::java\n\tString prefix = basicDataFormatting.bdf_prefix;\n\n**Type:**\n\njava.lang.String\n\n###bdf_send_data\nSet to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suf fix strings, if present, are still transmitted even when this option is disabled (default - enabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_data = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_enter\nSet to append an Enter character to the end of the processed data(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_enter = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_hex\nSet to send the data in hexadecimal format(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_hex = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_send_tab\nSet to append a tab character to the end of the processed data(default - disabled). Uses the [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE) enum.\n\n**Example Usage:**\n\n\t:::java\n\tbasicDataFormatting.bdf_send_tab = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###bdf_suffix\nAdd characters to the end of the data when sent.\n\n**Example Usage:**\n\n\t:::java\n\tString suffix = basicDataFormatting.bdf_suffix;\n\n**Type:**\n\njava.lang.String\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-Intent","name":"ProfileConfig.DataCapture.DataDelivery.Intent","md":"#ProfileConfig.DataCapture.DataDelivery.Intent\nHolds Intent configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tIntent intent = profileConfig.Intent;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###action\nGets and Sets the intent action.\n\n**Example Usage:**\n\n\t:::java\n\tString action = intent.action;\n\n**Type:**\n\njava.lang.String\n\n###basicDataFormatting\nGets and Sets intent INTENT_DELIVERY configuration object [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting).\n\n**Example Usage:**\n\n\t:::java\n\tintent.BasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting)\n\n###category\nGets and Sets the intent category.\n\n**Example Usage:**\n\n\t:::java\n\tString category = intent.category;\n\n**Type:**\n\njava.lang.String\n\n###delivery\nGets and Sets intent INTENT_DELIVERY configuration enum [ProfileConfig.INTENT_DELIVERY](#api-ProfileConfig?INTENT_DELIVERY).\n\n**Example Usage:**\n\n\t:::java\n\tintent.delivery = INTENT_DELIVERY.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.INTENT_DELIVERY](#api-ProfileConfig?INTENT_DELIVERY)\n\n###output_enabled\nGets and Sets intent ENABLED_STATE configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tintent.output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery-Keystroke","name":"ProfileConfig.DataCapture.DataDelivery.Keystroke","md":"#ProfileConfig.DataCapture.DataDelivery.Keystroke\nHolds Keystroke configuration settings.\n\n**Example Usage:**\n\n\t:::java\n\tKeystroke keystroke = profileConfig.dataCapture.dataDelivery.keystroke;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n\n###basicDataFormatting\nGets and Sets keystroke basic data formatting configuration object [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.BasicDataFormatting.bdf_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting)\n\n###ime_output_enabled\nGets and Sets keystroke ENABLED_STATE configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n###keystroke_action_char\nGets and Sets keystroke ACTION_KEY_CHAR configuration enum [ProfileConfig.ACTION_KEY_CHAR](#api-ProfileConfig?ACTION_KEY_CHAR).\n\n**Example Usage:**\n\n\t:::java\n\tkeystroke.keystroke_action_char = ACTION_KEY_CHAR.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ACTION_KEY_CHAR](#api-ProfileConfig?ACTION_KEY_CHAR)\n\n"},{"key":"api-ProfileConfig-DataCapture-DataDelivery","name":"ProfileConfig.DataCapture.DataDelivery","md":"#ProfileConfig.DataCapture.DataDelivery\nClass for dealing with DataDelivery profile data ProfileConfig.DataCapture.DataDelivery.\n\n**Example Usage:**\n\n\t:::java\n\tDataDelivery dataDelivery = profileConfig.dataCapture.dataDelivery;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###intent\nGets and Sets Intent configuration object [ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent).\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.intent.output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent)\n\n###keystroke\nGets and Sets Keystroke configuration object [ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke).\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.keystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke)\n\n"},{"key":"api-ProfileConfig-DataCapture-MSR","name":"ProfileConfig.DataCapture.MSR","md":"#ProfileConfig.DataCapture.MSR\nHolds MSR configuration settings\n\n**Example Usage:**\n\n\t:::java\n\tMSR msr = profileConfig.dataCapture.msr;\n\n**Version:**\n\n2.0\n\n##Constructors\n\n###ProfileConfig.DataCapture.MSR()\n\n##Public Fields\n\n###msr_input_enabled\nGets and Sets MSR enabled configuration enum [ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE).\n\n**Example Usage:**\n\n\t:::java\n\tmsr.msr_input_enabled = ENABLED_STATE.DEFAULT;\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ENABLED_STATE](#api-ProfileConfig?ENABLED_STATE)\n\n"},{"key":"api-ProfileConfig-DataCapture","name":"ProfileConfig.DataCapture","md":"#ProfileConfig.DataCapture\nClass for dealing with data capture profile data ProfileConfig.DataCapture\n\n**Example Usage:**\n\n\t:::java\n\tDataCapture dataCapture = profileConfig.dataCapture;\n\n**Version:**\n\n2.0\n\n##Public Fields\n\n###barcode\nGets and Sets Barcode configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.barcode.decoders.code11 = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.Barcode](#api-ProfileConfig-DataCapture-Barcode)\n\n###dataDelivery\nGets and Sets DataDelivery configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.dataCapture.dataDelivery.keystroke.ime_output_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.DataDelivery](#api-ProfileConfig-DataCapture-DataDelivery)\n\n###msr\nGets and Sets MSR configuration object.\n\n**Example Usage:**\n\n\t:::java\n\tprofileConfig.msr.msr_input_enabled = ENABLED_STATE.DEFAULT;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture.MSR](#api-ProfileConfig-DataCapture-MSR)\n\n\n"},{"key":"api-ProfileConfig","name":"ProfileConfig","md":"#ProfileConfig\nClass for dealing with profile data\n\n**Example Usage:**\n\n\t:::java\n\tProfileConfig profileConfig = new ProfileConfig();\n\n**Version:**\n\n2.0\n\n##Constructors\n\n###ProfileConfig()\nCreates a new instance of ProfileConfig.\n\n**Example Usage:**\n\n\t:::java\n\tProfileConfig profileConfig = new ProfileConfig();\n\n\n##Public Fields\n###activitySelection\nGets and Sets the activity selection for the profiles [ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection). If no activities are associated to profile, the profile will be associated to that application for that session.\n\n**Example Usage:**\n\n\t:::java\n\tActivitySelection activitySelection = profileConfig.activitySelection;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection)\n\n###dataCapture\nGets and Sets the profiles DataCapture object [ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture).\n\n**Example Usage:**\n\n\t:::java\n\tDataCapture dataCapture = profileConfig.dataCapture;\n\n\n**Type:**\n\ncom.symbol.emdk.[ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture)\n\n###modifiedDate\nGets and Sets the profiles modified date string.\n\n**Example Usage:**\n\n\t:::java\n\tString profileDate = profileConfig.modifiedDate;\n\n\n**Type:**\n\njava.lang.String\n\n###profileName\nGets and Sets the profile name.\n\n**Example Usage:**\n\n\t:::java\n\tString profileName = profileConfig.profileName;\n\n\n**Type:**\n\njava.lang.String\n\n##Public Enums\n###ACTION_KEY_CHAR\nKeystroke Output Action key character enables decoding of a special character embedded within a bar code or MSR data for use in native Android applications. This feature is helpful when populating or executing a form.\n\n**Example Usage:**\n\n\t:::java\n\tACTION_KEY_CHAR.NONE;\n\n\n**Values:**\n\n* **DEFAULT** - Default action key character configured on the device.\n* **NONE** - Action key character feature is disabled.\n* **TAB** - Tab character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n* **LINEFEED** - Line feed character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n* **CARRIAGERETURN** - Carriage return character code in a bar code is processed. When DataWedge detects this character code in a bar code, move the focus to the next field.\n\n###BOOKLAND_FORMAT\nLists the Bookland formats\n\n**Example Usage:**\n\n\t:::java\n\tBOOKLAND_FORMAT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default bookland format configured on device.\n* **ISBN_10** - 978 reported in 10 digit mode.\n* **ISBN_13** - 978/979 transmitted as EAN13 as per 2007 ISBN-13 protocol.\n\n###CHECK_DIGIT\nThe number of check digits to be verified. With MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit configured on device.\n* **ONE** - Verify one check digit.\n* **TWO** - Verify two check digits.\n\n###CHECK_DIGIT_SCHEME\nTwo algorithms are possible for the verification of the second MSI check digit. Select the algorithm used to encode the check digit.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_SCHEME.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit scheme configured on device.\n* **MOD_11_10** - First check digit is MOD 11 and second check digit is MOD 10.\n* **MOD_10_10** - Both check digits are MOD 10.\n\n###CHECK_DIGIT_TYPE\nVerify data integrity.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default check digit type configured on device.\n* **NO** - A check digit is not used.\n* **USS** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Uniform Symbology Specification (USS) check digit algorithm.\n* **OPCC** - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Optical Product Code Council (OPCC) check digit algorithm.\n\n###CODE_ID_TYPE\nA Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol.\n\n**Example Usage:**\n\n\t:::java\n\tCODE_ID_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default prefix configured on device.\n* **NONE** - No prefix.\n* **AIM** - A standards based three character prefix.\n* **SYMBOL** - A Symbol defined single character prefix.\n\n###COUPON_REPORT\nSupported Coupon modes\n\n**Example Usage:**\n\n\t:::java\n\tCOUPON_REPORT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default coupon reports mode configured on device.\n* **OLD** - Scanner will read only the old coupon format.\n* **NEW** - Scanner will read only the new GS1 DataBar coupon format.\n* **BOTH** - Scanner will read both old coupon format as well as the new GS1 DataBar coupon format.\n\n###DEVICETYPES\nList of supported scanner device types.\n\n**Example Usage:**\n\n\t:::java\n\tDEVICETYPES.INTERNAL_LASER1;\n\n\n**Values:**\n\n* **AUTO** - Default scanner device configured on device.\n* **INTERNAL_LASER1** - Internal laser.\n* **INTERNAL_CAMERA1** - Internal camera.\n* **INTERNAL_IMAGER1** - Internal imager.\n\n###ENABLED_STATE\nEnable states.\n\n**Example Usage:**\n\n\t:::java\n\tENABLED_STATE.FALSE;\n\n\n**Values:**\n\n* **DEFAULT** - Default enable state configured on device.\n* **FALSE** - Disabled.\n* **TRUE** - Enabled.\n\n###ILLUMINATION_MODE\nTurns camera illumination on and off. This option is only available when camera is selected in the Barcode input Scanner selection option.\n\n**Example Usage:**\n\n\t:::java\n\tILLUMINATION_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default illumination configured on device.\n* **OFF** - External illumination is always is off.\n* **ON** - External illumination is always on.\n\n###INTENT_DELIVERY\nAllows configuration of the Intent Output Plug-in for the profile. The Intent Output Plug-in allows the captured data to be sent to an application in the form of an implicit Intent.\n\n**Example Usage:**\n\n\t:::java\n\tINTENT_DELIVERY.SEND_VIA_STARTACTIVITY;\n\n\n**Values:**\n\n* **DEFAULT** - Default intent delivery type configured on the device.\n* **SEND_VIA_STARTACTIVITY** - Send output via StartActivity.\n* **SEND_VIA_STARTSERVICE** - Send output via startService.\n* **BROADCAST_INTENT** - Send output via Broadcast intent.\n\n###INVERSE_1D_MODE\nThis parameter allows the user to select decoding on inverse 1D bar codes.\n\n**Example Usage:**\n\n\t:::java\n\tINVERSE_1D_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default inverse 1D mode configured on device.\n* **DISABLED** - Disables decoding of inverse 1D symbologies.\n* **ENABLED** - Enables decoding of only inverse 1D symbologies.\n* **AUTO** - Allows decoding of both positive as well as inverse 1D symbologies.\n\n###ISBT128_CONTACT_MODE\nOption for concatenating pairs of ISBT128 code types.\n\n**Example Usage:**\n\n\t:::java\n\tISBT128_CONTACT_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default ISBT128 concatenation configured on device.\n* **NEVER** - Will ignore the barcode pair and only output decode data for only one of the barcodes.\n* **ALWAYS** - Will not decode if both the barcodes are not present or if one of them cannot be decoded. There must be two ISBT codes in order to decode and perform concatenation.\n* **AUTO** - Decodes and concatenates pairs of ISBT codes immediately. If only a single ISBT symbol is present, the device must decode the symbol the number of times set via DataWedge Configuration 4 - 1 1 Redundancy - Code128 before transmitting its data to confirm that there is no additional ISBT symbol.\n\n###LCD_MODE\nEnable or disable LCD mode (for Blockbuster imager devices only). LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones.\n\n**Example Usage:**\n\n\t:::java\n\tLCD_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default LCD mode configured on device.\n* **DISABLED** - Disables LCD mode.\n* **ENABLED** - Enables LCD mode.\n\n###LINEAR_SECURITY_LEVEL\nSets the number of times a bar code is read to confirm an accurate decode.\n\n**Example Usage:**\n\n\t:::java\n\tLINEAR_SECURITY_LEVEL.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default linear security level configured on device.\n* **SHORT_OR_CODABAR** - Two times read redundancy if short bar code or Codabar.\n* **ALL_TWICE** - Two times read redundancy for all bar codes (default).\n* **LONG_AND_SHORT** - Two times read redundancy for long bar codes, three times for short bar codes.\n* **ALL_THRICE** - Three times read redundancy for all bar codes.\n\n###PICK_LIST\nAllows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is tar geted for decode.\n\n**Example Usage:**\n\n\t:::java\n\tPICK_LIST.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default pick list configured on device.\n* **DISABLED** - Disables Picklist mode. Any bar code within the field of view can be decoded.\n* **ENABLED** - Enables the Picklist mode so that only the bar code that is directly under the cross-hair (reticle) is decoded. This is useful when used in conjunction with the static and dynamic reticle viewfinder modes. (Scan Module Only).\n* **CENTERED** - Enables the Picklist mode so that only the bar code in the center of the image is decoded. This is most useful when used in conjunction with the static and dynamic reticle viewfinder modes. Note: This mode is only valid for decoder modules that supports a viewfinder. If one tries to set this for a unsupported decoder then the device would issue an error. (Camera scanner only)\n\n###PREAMBLE\nControls the preamble applied to the bar code Preamble characters are part of the UPC symbol consisting of Country Code and System Character. Select the appropriate option to match the host system.\n\n**Example Usage:**\n\n\t:::java\n\tPREAMBLE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default preamble configured on device.\n* **NONE** - No preamble.\n* **SYS_CHAR** - System character preamble.\n* **COUNTRY_AND_SYS_CHAR** - Both country and system code preamble.\n\n###SECURITY_LEVEL\nThe scanner offers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application.\n\n**Example Usage:**\n\n\t:::java\n\tCHECK_DIGIT_TYPE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default security level configured on device.\n* **LEVEL_0** - This setting allows the scanner to operate fastest, while providing sufficient security in decoding \"in-spec\" UPC/EAN bar codes (default).\n* **LEVEL_1** - As bar code quality levels diminish, certain characters become prone to misdecodes before others (i.e., 1, 2, 7, 8). If the scanner is misdecoding poorly printed bar codes, and the misdecodes are limited to these characters, select this security level.\n* **LEVEL_2** - If the scanner is misdecoding poorly printed bar codes, and the misdecodes are not limited to characters 1, 2, 7, and 8, select this security level.\n* **LEVEL_3** - If the scanner is still misdecoding, select this security level. Be advised, selecting this option is an extreme measure against misdecoding severely out of spec bar codes. Selecting this level of security can significantly impair the decoding ability of the scanner. If this level of security is necessary, try to improve the quality of the bar codes.\n\n###SUPPLEMENTAL_MODE\nSupplemental modes.\n\n**Example Usage:**\n\n\t:::java\n\tSUPPLEMENTAL_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default supplemental mode configured on device.\n* **NO** - The scanner is presented with a UPC/EAN plus supplemental symbol, the scanner decodes UPC/EAN and ignores the supplemental characters.\n* **ALWAYS** - The scanner only decodes UPC/EAN symbols with supplemental characters, and ignores symbols without supplementals.\n* **AUTO** - The scanner decodes UPC/EAN symbols with supplemental characters immediately . If the symbol does not have a supplemental, the scanner must decode the bar code the number of times set via UPC/EAN Supplemental Redundancy before transmitting its data to confirm that there is no supplemental.\n* **SMART** - Enables smart supplementals. In this mode the decoder returns the decoded value of the main block right away if it does not belong to one of the following supplemental types: 378, 379, 977, 978, 979, 414, 419, 434 or 439. If the bar code starts with one of the prefixes it searches the image more aggressively for a supplemental. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* **S_378_379** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 378 or 379. Disables reading of supplementals for any other UPC/EAN bar code not starting with 378 or 379. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* **S_978_979** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 978 or 979. Disables reading of supplementals for another UPC/EAN bar code not starting with 978 or 979. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* **S_414_419_434_439** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 414, 419, 434 or 439. Disables reading of supplementals for another UPC/EAN bar code 4 - 16 not starting with 414, 419, 434 or 439. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* **S_977** - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 977. Disables reading of supplementals for another UPC/EAN barcode not starting with 977. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\n###UCC_LINK_MODE\nDescribes the UCC link mode state.\n\n**Example Usage:**\n\n\t:::java\n\tUCC_LINK_MODE.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default UCC link mode configured on device.\n* **LINK_FLAG_IGNORED** - 1D component is transmitted regardless of whether a 2D component is detected.\n* **ALWAYS_LINKED** - 1D and the 2D components are transmitted. If 2D is not present, the 1D component is not transmitted.\n* **AUTO_DISCRIMINATE** - the digital scanner determines if there is a 2D portion, then transmits the 1D component, as well as the 2D portion if present (default). (default).\n\n###VERIFY_CHECK_DIGIT\nCheck the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code.\n\n**Example Usage:**\n\n\t:::java\n\tVERIFY_CHECK_DIGIT.DEFAULT;\n\n\n**Values:**\n\n* **DEFAULT** - Default verify check digit scheme configured on device.\n* **NO** - Do not verify check digit.\n* **ONE** - Bar code contains one check digit.\n* **TWO** - Bar code contains two check digits.\n\n###VIEWFINDER_MODE\nConfigures the Viewfinder modes supported for camera scanning.\n\n**Example Usage:**\n\n\t:::java\n\tVIEWFINDER_MODE.ENABLED;\n\n\n**Values:**\n\n* **DEFAULT** - Default view finder mode configured on the device.\n* **DISABLED** - Viewfinder disabled. Viewfinder is not displayed during aiming or scanning.\n* **ENABLED** - Viewfinder enabled. Displays the images captured by the camera on the screen.\n* **STATIC_RECTICLE** - Viewfinder enabled with locate reticle. Displays the viewfinder as well as draws a red reticle in the center of the screen which helps with tracking the barcode.\n"},{"key":"api-ProfileManager","name":"ProfileManager","md":"#ProfileManager\nThis class handles all the profile related functions.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);\n\t}\n\n**Version:**\n\n2.0\n\n##Public Methods\n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, Document extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\tDocumentBuilder db = dbf.newDocumentBuilder();\n\tDocument extraData;\n\textraData = db.newDocument();\n\tprofileManager.processProfile(\"Profile1\", PROFILE_FLAG.GET, extraData);\n\n**Parameters:**\n\n* **profileName** - Name of the profile.\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n* **extraData** - This can be used to provide data for processing action.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, java.lang.String[] extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\tprofileManager.processProfile(\"Profile1\", PROFILE_FLAG.GET, new String[]{\"\"});\n\n**Parameters:**\n\n* **profileName** - Name of the profile.\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n* **extraData** - This can be used to provide data for processing action.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n###processProfile(String profileName, ProfileManager.PROFILE_FLAG profileFlag, ProfileConfig extraData)\nProcesses the given profile based on the data provided and the flag and return status of the action.\n\n**Example Usage:**\n\n\t:::java\n\t//Create the ProfileConfig object\n\tProfileConfig profileConfigObj = new ProfileConfig();\n\t//Get the ProfileConfig from the profile XML\n\tEMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\t//Set the code128\n\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.TRUE;\n\t//call processPrfoile with profile name, SET flag and config data to update the profile\n\tEMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\n**Parameters:**\n\n* **profileName** - Name of the profile.\n* **profileFlag** - [ProfileManager.PROFILE_FLAG](#api-ProfileManager?PROFILE_FLAG) If the profileFlag is set to SET, and if the given profile is not available in the EMDKConfig.xml, it will look for valid profile in extraData argument and if present, the profile will be added to the internal XML volatile repository and also applied to the device. If the profile is present in the EMDKConfig.xml, it will be applied to the device. If profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in extraData.\n* **extraData** - [ProfileConfig](#api-ProfileConfig) This can be used to provide data for processing action.\n\n**Returns:**\n\ncom.symbol.emdk.EMDKResults - [EMDKResults](#api-EMDKResults) object.\n\n##Public Enums\n\n###ProfileManager.PROFILE_FLAG\nAll the possible actions for [ProfileManager.processProfile(String, PROFILE_FLAG, Document)](#api-ProfileManager?processProfile(String, PROFILE_FLAG, Document)) and [ProfileManager.processProfile(String, PROFILE_FLAG, String[])](#api-ProfileManager?processProfile(String, PROFILE_FLAG, String[]))is enumerated here.\n\n**Example Usage:**\n\n\t:::java\n\tPROFILE_FLAG.SET\n\n**Values:**\n\n* **SET** - Creates a profile with given XML data. If the profile is already created, this activates the profile if it is not bound to any activity.\n* **GET** - Retrieves a profile from internal repository.\n\n"},{"key":"api-VersionManager","name":"VersionManager","md":"#VersionManager\nVersion information can be captured from this class.\n\n**Example Usage:**\n\n\t:::java\n\t@Override\n\tpublic void onOpened(EMDKManager emdkmanager)\n\t{\n\tVersionManager versionManager = (VersionManager)emdkmanager.getInstance(FEATURE_TYPE.VERSION);\n\t}\n\n**Version:**\n\n2.0\n\n##Public Methods\n\n###getVersion(VersionManager.VERSION_TYPE versionKey)\n\nGets the version of the specified [VersionManager.VERSION_TYPE](#api-VersionManager?VERSION_TYPE)\n\n**Example Usage:**\n\n\t:::java\n\tversionManager.getVersion(VERSION_TYPE.EMDK)\n\n**Parameters:**\n\n**versionKey** - [VersionManager.VERSION_TYPE](#api-VersionManager?VERSION_TYPE)\n\n**Returns:**\n\njava.lang.String - Version number\n\n##Public Enums\n\n###VERSION_TYPE\nAll the version keys for [VersionManager.getVersion(VersionManager.VERSION_TYPE versionKey)](#api-VersionManager?getVersion(VersionManager.VERSION_TYPE versionKey)) are enumerated here.\n\n**Example Usage:**\n\n\t:::java\n\tVERSION_TYPE.EMDK\n\n**Values:**\n\n* **EMDK** - EMDK version\n"},{"key":"guide-about","name":" About EMDK For Android","md":"# About EMDK For Android\n\n## Overview\nWhen applications require tight integration and performance, the EMDK for Android delivers the feature set and capabilities you have grown to expect from Motorola. With a comprehensive set of APIs and sample code, the EMDK enables you to take full advantage of what our devices have to offer.   \n\n## Requirements\nThe following software must be installed prior to using the EMDK for Android.\n\n* Microsoft Windows 7 (32-bit and 64-bit)  or Microsoft® Windows 8 (32-bit and 64-bit) or Microsoft® Windows 8.1 (32-bit and 64-bit)\n* Java Development Kit (JDK) v7u45 or higher\n* Android Developer Tools (ADT) v22.3.0-887826 or higher\n\n## Devices Supported\nAlthough EMDK for Android has been designed to work with all Motorola Solutions mobile computers running Android, it should only be used to develop applications for approved devices.  For a complete listing of approved devices go to the download page for this product .\n\n* MC40\n* MC67\n* TC55\n\n## Components\n\n### Profile Manager\nThe EMDK's exclusive [Profile Manager](#guide-profiles-usingwizard) Technology is an additional advantage for developers giving you a GUI based development tool built on our open framework. This allows you to write fewer lines of code resulting in reduced development time, effort and errors. This innovative feature not only gives you easy access to critical functions such as bar code scanning and transaction processing via a magnetic stripe reader (MSR) but also functionality not available in Google's Android SDK.   \n### EMDK Device Runtimes\nIn order for your application to use the EMDK For Android, you will need to install the EMDK Device Runtime on each device. This runtime is included with the EMDK For Android installation. Check the [Programmers Guide](#guide-tutorial-tutdatacaptureprofile) for instructions. In the future the EMDK Services will be included with the default operating system for the device.\n\n### Samples & Programmer's Guide\nThere are sample projects that are included as part of the EMDK For Android installation. You can import the project into Eclipse and run on your device. Look at the [Sample Guide](#guide-sample-sampledatacaptureprofile) for more details on using these samples. You can also reference the [Programmers Guide](#guide-tutorial-tutdatacaptureprofile) for a complete walk-through of building your first EMDk For Android application.\n\n### Java APIs\nThe EMDK for Android 2.0 offers access to the device's [Barcode](#guide-profiles-profilebarcode) and [MSR](#guide-profiles-profilemsr) capabilities though the use of Profiles. Profiles are created through Eclipse using the [Profile Manager Wizard](#guide-profiles-usingwizard) and packaged up with your application. Your application then chooses to enable the profiles when needed using the [ProfileManager APIs](#guide-reference-EMDKList). \n\nYour application can also choose to modify individual settings of that profile on the fly during application running. In order to receive data back from the running profile, you would configure it to either send the data as keystrokes, or to trigger an Intent that your application is ready to handle.\n\nIn the near future, the EMDK For Android will contain other types of profiles for device configuration like Wi-Fi, Power, etc. It will also contain traditional native Java APIs for direct access to device capabilities without the use of profiles.\n\n### Intent APIs\nThe EMDK for Android will continue to support the [DataCapture](#guide-reference-refdatacaptureintent) and [Battery Intent](#guide-reference-refbatteryintent) APIs that were previously available on individual device types. \n\n<a name=\"faqs\"></a>\n## Frequently Asked Questions\n**Q: Where can I download a copy of the EMDK for Android?**\n\nA: The EMDK for Android can be downloaded from Support Portal [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Developer+Kits+and+Software+Tools/Mobile%20Computer%20Software%20and%20Developer%20Tools_US-EN)\n\n**Q: Is there a cost for the EMDK for Android?**\n\nA: No, EMDK for Android is available for free and can be downloaded from Support Portal [here](https://portal.motorolasolutions.com/Support/US-EN/Mobile+Networks+RFID+and+BarCode+Scanners/Mobile+Computers/Developer+Kits+and+Software+Tools/Mobile%20Computer%20Software%20and%20Developer%20Tools_US-EN)\n\n**Q: Which device does the EMDK for Android v2.0 support and which operating systems?**\n\nA: The EMDK for Android v2.0 supports the following Jelly Bean devices only:\n\n* MC40\n* MC67\n* TC55\n\n**Q: Which desktop operating systems are supported by the EMDK for Android v2.0 support?**\n\nA: The EMDK for Android v2.0 is supported on Windows 7, Windows 8 and Windows 8.1.\n\n**Q: Can the EMDK for Android v2.0 be installed on Windows XP?**\n\nA: No, the EMDK for Android v2.0 does not support Windows XP and there are no current plans to support this operating system.\n\n**Q: Can the EMDK for Android v2.0 be installed on a MAC?**\n\nA: No, the EMDK for Android v2.0 does not support MAC OS. MAC support will be considered in a future release of the EMDK for Android. However you can use virtualization solutions such as VMware fusion to run one of the supported Windows operating systems on a MAC.\n\n**Q: Can the EMDK for Android v2.0 be used with Android Studio?**\n\nA: No, the EMDK for Android v2.0 does not support Android Studio. Support for Android Studio will be made available in a future release of the EMDK for Android.\n\n**Q: What documentation is available for EMDK for Android v2.0 and where can I obtain it?**\n\nA: Documentation for the EMDK can be downloaded from Launch Pad here:\n\n* [EMDK Landing page](https://developer.motorolasolutions.com/community/android/emdk) \n* [Tutorials](https://developer.motorolasolutions.com/community/android/emdk/tutorials) \n* [Samples](https://developer.motorolasolutions.com/community/android/emdk/samples) \n* [API Reference](https://developer.motorolasolutions.com/community/android/emdk/reference) \n* [Profile Manager](https://developer.motorolasolutions.com/community/android/emdk/profiles)\n\n**Q: Why is this release of the EMDK for Android called version 2.0 and is there a version 1.0?**\n\nA: The EMDK for Android version 2.0 is the next evolution of the Data Capture SDK. While the Data Capture SDK was not explicitly named “EMDK”, this previously released version is considered the EMDK for Android v1.0. The EMDK for Android version 2.0 contains all of the 1.0 functionality (Data Capture and Battery Intent APIs), and reinforces our commitment in supporting development using the standard Android Intent inter-application messaging system. As devices continue to progress, the EMDK for Android will provide access to those new capabilities through our Profile Manager and APIs, including Intents.\n\n**Q: Will my app run across the entire MSI android portfolio?**\n\nA: EMDK for Android is designed to be compatible with all Motorola devices, Android OS and BSPs. However, the compatibility of your application will depend on not just the EMDK architecture, but also on Google’s SDK.\n\n**Q: Can the EMDK for Android v2.0 be used as a staging tool?**\n\nA: The EMDK for Android v2.0 is targeted for developers and the development of applications. Customers may develop an application which configures aspects of a device however the EMDK is not a staging tool.\n\n**Q: I understand the EMDK for Android offers a feature called Profile Manager, what is this?**\n\nA: The Profile Manager is provided as an Eclipse plug-in that offers developers a GUI development tool. The tool creates a “profile” which is comprised of settings defined by the developer for value-add features such as Barcode Scanning & MSR. In the future we will be releasing profiles for Wi-Fi (Fusion), Clock, Power, and GPRS. These settings can then be invoked and modified within the applications through the Profile Manager API.\n\n**Q: What are the benefits of the Profile Manager GUI and API?**\n\nA: The Profile Manager GUI and APIs allow you to, quickly and easily leverage device value-add features. The user interface makes it easy for developers to pick and choose the settings they need, eliminating the need to code these options. With the Profile Manager API, developers can invoke and modify settings as needed within their application. This gives you the fine level of control you need while reducing development time, effort and errors.\n\n**Q: Does the EMDK for Android v2.0 offer APIs for direct control of device value adds?**\n\nA: Yes, the EMDK for Android v2.0 currently offers the Data Capture and Battery Intent which allows you to utilize standard Android inter-application messaging system for these features. Device value-adds can also be managed through the Profile Manager API. Future releases of the EMDK will also offer traditional Java APIs similar to what has been offered for Windows CE and Windows Mobile.\n\n**Q: Does the EMDK for Android v2.0 support traditional JAVA APIs?**\n\nA: The EMDK for Android v2.0 offers Intent base APIs. However future releases will offer more traditional JAVA APIs similar to what has been offered for Windows CE and Windows Mobile.\n\n**Q: Does the EMDK for Android v2.0 support Android Intents?**\n\nA: Yes, the EMDK for Android v2.0 offers the Data Capture and Battery Intents which allow you to utilize standard Android inter-application messaging system for these features.\n\n**Q: I understand that the EMDK for Android supports Intents; what is an Intent?**\n\nA: An Intent is a standard Android inter-application messaging mechanism. For more information please see Google’s documentation on Android Intent; http://developer.android.com/reference/android/content/Intent.html\n\n**Q: How does Mobility Extensions (MX) relate to the EMDK for Android?**\n\nA: The EMDK for Android provides developers with a programmatic interface to the MX value-add features on our devices. Future releases of the EMDK for Android will offer additional features as we continue to expand MX capabilities.\n\n**Q: I have developed my application with the EMDK for .NET and now want to migrate to Android. Does the EMDK for Android support the same features or APIs?**\n\nA: The EMDK for Android is designed to expose MX value-add features and provides developers with a GUI tool to help reduce the development effort. Many of the device specific features such as Barcode scanning and MSR will be provided as part of the EMDK for Android. However standard Android APIs from Google such as Audio and Keyboard will not. This is done in order to avoid application fragmentation. The EMDK for Android v2.0 is meant to be used alongside the Google Android SDK and together provide many of the features developers need in order to migrate their applications to Android. Below is the list of the EMDK for .NET APIs along with equivalent EMDK for Android v2.0 APIs, Profiles, and the standard Google APIs. This list is a reference guide in order to help when migrating applications to Android.\n\n\n<table>\n\t<tr>\n\t\t<th>EMDK for .NET</th>\n\t\t<th>EMDK for Android 2.0</th>\n\t\t<th>Google Android SDK</th>\n\t</tr>\n\t<tr>\n\t\t<td>Barcode (Symbol.Barcode)</td>\n\t\t<td> Data Capture Intent Barcode Profile</td>\n\t\t<td>X</td>\n\t</tr>\n\t<tr>\n\t\t<td>Image Capture (Symbol.Imaging)</td>\n\t\t<td> X </td>\n\t\t<td>android.hardware.camera</td>\n\t</tr>\n\t<tr>\n\t\t<td>Display (Symbol.Display)</td>\n\t\t<td>X</td>\n\t\t<td>android.view.Display</td>\n\t</tr>\n\t<tr>\n\t\t<td>Audio (Symbol.Audio)</td>\n\t\t<td>X</td>\n\t\t<td>android.media.AudioManager</td>\n\t</tr>\n\t<tr>\n\t\t<td>WLAN (Symbol.Fusion)</td>\n\t\t<td> X</td>\n\t\t<td> android.net.wifi.WifiManager<br/> android.net.wifi.p2p.WifiP2pManager</td>\n\t</tr>\n\t<tr>\n\t\t<td>Battery Mgt (Symbol.ResCoord)</td>\n\t\t<td>Battery Intent</td>\n\t\t<td>android.os.BatteryManager</td>\n\t</tr>\n\t<tr>\n\t\t<td>Keyboard (Symbol.Keyboard)</td>\n\t\t<td>X</td>\n\t\t<td>android.inputmethodservice.Keyboard.Key</td>\n\t</tr>\n\t<tr>\n\t\t<td>MagStripe (Symbol.MagrStripe)</td>\n\t\t<td>Data Capture Intent MSR Profile</td>\n\t\t<td>X</td>\n\t</tr>\n\t<tr>\n\t\t<td>Sensor (Symbol.Sensor)</td>\n\t\t<td>X</td>\n\t\t<td>android.hardware.SensorManager</td>\n\t</tr>\n\t<tr>\n\t\t<td>Bluetooth (Symbol.WPAN)</td>\n\t\t<td>X</td>\n\t\t<td> android.BluetoothAdapter</td>\n\t</tr>\n\t<tr>\n\t\t<td>Database (Sysm.data.SqlServerCe)</td>\n\t\t<td>X</td>\n\t\t<td>android.database.sqlite</td>\n\t</tr>\n\t<tr>\n\t\t<td>NFC</td>\n\t\t<td>X</td>\n\t\t<td>android.nfc</td>\n\t</tr>\n\t<tr>\n\t\t<td>Notification (Symbol.ResCoord)</td>\n\t\t<td>X</td>\n\t\t<td>Android.service.notification</td>\n\t</tr>\n\t<tr>\n\t\t<td>Printing (Symbol.printing)</td>\n\t\t<td>X</td>\n\t\t<td>android.print</td>\n\t</tr>\n\t<tr>\n\t\t<td>XML serialization (System.XML) </td>\n\t\t<td>X</td>\n\t\t<td> org.xmlpull.v1.XmlSerializer<br/> org.xml.sax</td>\n\t</tr>\n\t<tr>\n\t\t<td>Interop Services (System.Runtime.InteropServices) </td>\n\t\t<td>X </td>\n\t\t<td>Java Native Interface</td>\n\t</tr>\n\t<tr>\n\t\t<td>Threading (System.Threading) </td>\n\t\t<td>X </td>\n\t\t<td>java.lang.Thread</td>\n\t</tr>\n\t<tr>\n\t\t<td>Encryption (System.Security.Cryptography) </td>\n\t\t<td>X </td>\n\t\t<td>javax.crypto</td>\n\t</tr>\n\t<tr>\n\t\t<td>Message Queue (System.Messaging) </td>\n\t\t<td>X </td>\n\t\t<td>android.os.MessageQueue</td>\n\t</tr>\n\t<tr>\n\t\t<td>Network Communications (System.Net/System.Net.Sockets) </td>\n\t\t<td>X </td>\n\t\t<td>java.net.Socket</td>\n\t</tr>\n\t<tr>\n\t\t<td>File management (System.IO…) </td>\n\t\t<td>X </td>\n\t\t<td>java.io.File</td>\n\t</tr>\n</table>\n\n\n\n\n\n\n"},{"key":"guide-profiles-profileactivity","name":" Activity Selection - Profile Reference","md":"# Activity Selection - Profile Reference\n\n## Overview\n\nWhen creating a profile for [Barcode](#guide-profiles-profilebarcode) or [MSR](#guide-profiles-profilemsr) data capture you can configure an Activity Selector to automate the process of activating and deactivating the profile. This allows for automated profile management of complex applications. \n\n##Activity Selector\n\n* Applications - List of applications this profile may be active during. \n\t* Applications names are the formal package definition of the application. For example \"com.symbol.profiledatacapturesample1\". \n* Activities -  List of activities within the selected application that a profile should be active for. \n\t*  For Example \"MainActivity\"."},{"key":"guide-profiles-profilebarcode","name":" Barcode - Profile Settings Reference","md":"# Barcode - Profile Settings Reference\n\n## Overview\nIn order to get Barcode data in your application, you must create a profile with two profile features selected:\n\n* Barcode\n* Intent or Keystroke\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed settings for scanner behavior as well as individual barcode symbology settings.\n\nThe `Intent` or `Keystroke` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled.\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n## Barcode Settings Reference\n\n### Enabled\nEnables or disables this feature. Default is enabled.\n\n### Scanner Selection\nConfigures which scanning device to use for data capture.\n\n* Auto - Automatically determines the best scanning device. If a Scan Module or Scan/MSR Module is installed on the MC40, then the 2D imager is selected. Otherwise the camera is selected.\n* Camera Scanner - Scanning is performed with the rear-facing camera.\n* 2D Imager - Scanning is performed using the installed Scan or Scan/MSR module.\n\n### Decoders\nConfigures which bar code decoders are enabled or disabled. For best performance disable all unnecessary decoders. By default the most commonly used decoders are enabled (shown below with an asterisk). The supported decoders are:\n\n* Australian Postal \n* Canadian Postal\n* Chinese 2 of 5 \n* Codabar*\n* Code 11\n* Code 39*\n* Code 93 \n* Code 128* \n* Composite AB\n* Composite C \n* Datamatrix* \n* Discrete 2 of 5 \n* Dutch Postal MSI\n* EAN-8*\n* EAN-13*\n* GS1 DataBar* \n* GS1 DataBar Expanded*\n* GS1 DataBar Limited \n* Japanese Postal \n* Korean 3 of 5\n* Interleaved 2 of 5\n* Matrix 2 of 5 \n* Maxicode*\n* MicroPDF\n* MicroQR Aztec*\n* PDF417*\n* QR Code* \n* TLC 39\n* Trioptic 39\n* UK Postal\n* UPC-A*\n* UPC-E0* \n* UPC-E1\n* US4state FICS \n* USPostnet \n* USPlanet\n* Webcode\n\n### UPCA\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCA preamble:\n\t* Preamble None - Transmit no preamble.\n\t* Preamble Sys Char - Transmit System Character only (default).\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (“0” for USA). Select the appropriate option to match the host system.\n\n### UPCE0\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCE0 preamble:\n\t* Preamble Sys Char - Transmit System Character only.\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (“0” for USA).\n\t* Preamble None - Transmit no preamble (default). Select the appropriate option to match the host system.\n* Convert UPCE0 To UPCA - Enable to convert UPCE0 (zero suppressed) decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is affected by UPC-A programming selections. Disable to transmit UPCE0 decoded data as UPCE0 data, without conversion (default - disabled).\n\n### Code128\n* Length1 - Use to set decode lengths (default - 0).\n* Length2 - Use to set decode lengths (default - 55).\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Enable Plain Code 128 - Flag to enable other 128 sub types (besides GS1-128 and ISBT-128).\n* Enable GS1-128 - Set the GS1 128 subtype. \n* Enable ISBT128 - Set the ISBT128 subtype. \n* ISBT128 Concatenation Mode - Select an option for concatenating pairs of ISBT code types:\n\t* Concat Mode Never - Do not concatenate pairs of ISBT codes encountered (default).\n\t* Concat Mode Always - There must be two ISBT codes in order to decode and perform concatenation. Does not decode single ISBT symbols.\n\t* Concat Mode Auto - Decodes and concatenates pairs of ISBT codes immediately. If only a single ISBT symbol is present, the device must decode the symbol the number of times set via Redundancy - Code128 before transmitting its data to confirm that there is no additional ISBT symbol.\n* Check ISBT Table - The ISBT specification includes a table that lists several types of ISBT bar codes that are commonly used in pairs. If ISBT128 Concat Mode is set, enable Check ISBT Table to concatenate only those pairs found in this table. Other types of ISBT codes are not concatenated. \n* Security Level - The scanner offers four levels of decode security for Code 128 bar codes. Select increasing levels of security for decreasing levels of bar code quality. There is an inverse relationship between security and scanner aggressiveness, so choose only that level of security necessary for any given application.\n\t* Security Level 0 - This setting allows the scanner to operate in its most aggressive state, while providing sufficient security in decoding most “in-spec” bar codes.\n\t* Security Level 1 - This setting eliminates most misdecodes.\n\t* Security Level 2 - Select this option if Security level 1 fails to eliminate misdecodes.\n\t* Security Level 3 - If Security Level 2 is selected and misdecodes still occur, select this security level. Be advised, selecting this option is an extreme measure against mis-decoding severely out of spec bar codes. Selecting this level of security significantly impairs the decoding ability of the scanner. If this level of security is needed, try to improve the quality of the bar codes.\n\n### Code39\n* Length1 - Use to set decode lengths. \n* Length2 - Use to set decode lengths 4.\n* Verify Check Digit - Enable this feature to check the integrity of all Code 39 symbols to verify that the data complies with a specified check digit algorithm. The digital scanner decodes only those Code 39 symbols that include a modulo 43 check digit. Enable this feature only if the Code 39 symbols contain a modulo 43 check digit (default - disabled).\n* Report Check Digit - Transmit Code 39 data with or without the check digit. \n* Full ASCII - Code 39 Full ASCII is a variant of Code 39 that pairs characters to encode the full ASCII character set. To enable or disable Code 39 Full ASCII,\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Convert Code39 To Code32 - Code 32 is a variant of Code 39 used by the Italian pharmaceutical industry. Scan the appropriate bar code below to enable or disable converting Code 39 to Code 32.\n* Report Code32 Prefix - Scan the appropriate bar code to enable or disable adding the prefix character “A” to all Code 32 bar codes.\n* Security Level - Options: Security level 0, Security Level 1, Security Level 2 and Security Level 3.\n\n### Interleaved 2of5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Check Digit\n\t* No Check Digit - A check digit is not used. \n\t* USS Check Digit - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Uniform Symbology Specification (USS) check digit algorithm.\n\t* OPCC Check Digit - Select to check the integrity of all Interleaved 2 of 5 symbols to verify the data complies with either the Optical Product Code Council (OPCC) check digit algorithm.\n* Report Check Digit - Transmit Interleaved 2 of 5 data with or without the check digit. \n* Convert ITF-14 To EAN13 - Convert 14-character Interleaved 2 of 5 bar codes to EAN-13, and transmit as EAN-13. The Interleaved 2 of 5 bar code must be enabled and must have a leading zero and a valid EAN-13 check digit. \n\n### Composite AB\n* UCC Link Mode\n\t* Link Flag ignored - 1D component is transmitted regardless of whether a 2D component is detected.\n\t* Always Linked - 1D and the 2D components are transmitted. If 2D is not present, the 1D component is not transmitted.\n\t* Auto Discriminate - the digital scanner determines if there is a 2D portion, then transmits the 1D component, as well as the 2D portion if present. (default).\n\n### UK Postal\n* Report Check Digit - Transmit UK Postal data with or without the check digit. \n\n### Codabar\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* CLSI Editing - Enable this parameter to strip the start and stop characters and insert a space after the first, fifth, and tenth characters of a 14-character Codabar symbol. Enable this feature if the host system requires this data format.\n* NOTIS Editing - Enable this parameter to strip the start and stop characters from a decoded Codabar symbol. Enable this feature if the host system requires this data format.\n* MSI\n* Length 1 - Use to set decode lengths.\n* Length 2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Check Digit - With MSI symbols, one check digit is mandatory and always verified by the reader. The second check digit is optional.\n\t* One Check Digit - Verify one check digit.\n\t* Two Check Digits - Verify two check digits.\n* Check Digit Scheme - Two algorithms are possible for the verification of the second MSI check digit.\nSelect the algorithm used to encode the check digit.\n\t* Mod-11-10 - First check digit is MOD 11 and second check digit is MOD 10.\n\t* Mod-10-10 - Both check digits are MOD 10.\n* Report Check Digit - Transmit MSI data with or without the check digit. \n\n### Code93\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Discrete 2 of 5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n\n### Code11\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Verify Check Digit - Check the integrity of all Code 11 symbols to verify that the data complies with the specified check digit algorithm. This selects the check digit mechanism for the decoded Code 11 bar code.\n\t* No Check Digit - Do not verify check digit.\n\t* 1 Check Digit - Bar code contains one check digit.\n\t* 2 Check Digits - bar code contains two check digits.\n* Report Check DIgit - Transmit Code 11 data with or without the check digit. \n\n### Webcode\n* Webcode Subtype - Enables the decoding of the GT Webcode subtype. \n* Matrix 2 of 5\n* Length1 - Use to set decode lengths.\n* Length2 - Use to set decode lengths.\n* Redundancy - Sets the reader to read the bar code twice before accepting data. \n* Report Check Digit - Transmit Matrix 2 of 5 data with or without the check digit. \n* Verify Check Digit - Enable this feature to check the integrity of all Matrix 2 of 5 symbols to verify that the data complies with a specified check digit algorithm.\n\n### UPCE1\n* Report Check Digit - The check digit is the last character of the symbol used to verify the integrity of the data. Enables or disables this option. \n* Preamble - Preamble characters are part of the UPC symbol consisting of Country Code and System Character. There are three options for transmitting a UPCE1 preamble:\n\t* Preamble Sys Char - Transmit System Character only.\n\t* Preamble Country and Sys Char - Transmit System Character and Country Code (“0” for USA).\n\t* Preamble None - Transmit no preamble (default). Select the appropriate option to match the host system.\n* Convert UPCE1 To UPCA - Enable this to convert UPCE1 decoded data to UPC-A format before transmission. After conversion, the data follows UPC-A format and is affected by UPC-A programming selections. Disable this to transmit UPCE1 decoded data as UPCE1 data, without conversion.\n\n### Decode Lengths\nThe allowable decode lengths are specified by options Length1 and Length2 as follows: \n\n* Variable length: Decode symbols containing any number of characters.\n\t* Set both Length1 and Length2 to 0.\n* Range: Decode a symbol with a specific length range (from a to b, including a and b).\n\t* Set Length1 to a and set Length2 to b.\n* Two Discrete Lengths: Decode only symbols containing either of two selected lengths.\n\t* Set either Length1 or Length2 to the specific lengths.\n* One Discrete Length: Decode only symbols containing a specific length.\n\t* Set both Length1 and Length2 to the specific length.\n\n### UPC EAN Params\nAllows the configuration of the parameters that apply to more than one UPC or EAN decoder.\n\n* Security Level - The scanner offers four levels of decode security for UPC/EAN bar codes. Select higher security levels for lower quality bar codes. There is an inverse relationship between security and decode speed, so be sure to choose only that level of security necessary for the application.\n\t* Level 0 - This default setting allows the scanner to operate fastest, while providing sufficient security in decoding “in-spec” UPC/EAN bar codes.\n\t* Level 1 - As bar code quality levels diminish, certain characters become prone to misdecodes before others (i.e., 1, 2, 7, 8). If the scanner is misdecoding poorly printed bar codes, and the misdecodes are limited to these characters, select this security level.\n\t* Level 2 - If the scanner is misdecoding poorly printed bar codes, and the misdecodes are not limited to characters 1, 2, 7, and 8, select this security level.\n\t* Level 3 - If the scanner is still misdecoding, select this security level. Be advised, selecting this option is an extreme measure against misdecoding severely out of spec bar codes. Selecting this level of security can significantly impair the decoding ability of the scanner. If this level of security is necessary, try to improve the quality of the bar codes.\n* Supplemental2 - Enables or disables this option. \n* Supplemental5 - Enables or disables this option. \n* Supplemental Mode\n\t* No Supplementals - the scanner is presented with a UPC/EAN plus supplemental symbol, the\n\tscanner decodes UPC/EAN and ignores the supplemental characters.\n\t* Supplemental Always - the scanner only decodes UPC/EAN symbols with supplemental characters, and ignores symbols without supplementals.\n\t* Supplements Auto - the scanner decodes UPC/EAN symbols with supplemental characters immediately. If the symbol does not have a supplemental, the scanner must decode the bar code the number of times set via UPC/EAN Supplemental Redundancy before transmitting its data to confirm that there is no supplemental.\n\t* Supplemental Smart - Enables smart supplementals. In this mode the decoder returns the decoded value of the main block right away if it does not belong to one of the following supplemental types: 378, 379, 977, 978, 979, 414, 419, 434 or 439. If the bar code starts with one of the prefixes it searches the image more aggressively for a supplemental. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 378-379 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 378 or 379. Disables reading of supplementals for any other UPC/EAN bar code not starting with 378 or 379. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 978-979 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 978 or 979. Disables reading of supplementals for another UPC/EAN bar code not starting with 978 or 979. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main barcode is returned.\n\t* Supplemental 414-419-434-439 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 414, 419, 434 or 439. Disables reading of supplementals for another UPC/EAN bar code not starting with 414, 419, 434 or 439. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n\t* Supplemental 977 - Enables (auto-discriminate) supplemental for UPC/EAN codes starting with 977. Disables reading of supplementals for another UPC/EAN barcode not starting with 977. Tries to scan the supplemental if it is present. If the supplemental scanning failed, then the main bar code is returned.\n* Retry Count - Retry count for auto-discriminating for supplementals. Possible values are 2 to 20 inclusive. Note that this flag is only considered if Supplemental Mode - UPC EAN is set to one of the following values: Supplementals Auto, Supplementals Smart, Supplementals 378-379, Supplementals 978-979, Supplementals 977 or Supplementals 414-419-434-439 (2 to 20).\n* Bookland - Enable or disable this option. \n* Coupon - Enables Coupon code decoding. Note that in order to successfully decode Coupon codes, all\nof the correct decoders must be enabled. \n* Convert DataBar To UPC EAN - If this is set it converts DataBar bar codes to UPC/EAN format. For this setting to work UPC/EAN symbologies must be enabled. \n\n### Reader Params\nAllows the configuration of parameters specific to the selected bar code reader.\n\n* Beam Timer - Sets the maximum amount of time that the reader remains on (0 - 60,000 ms in increments of 100 ms). A value of 0 sets the reader to stay on indefinitely.\n* Linear Security Level - Sets the number of times a bar code is read to confirm an accurate decode.\n\t* Security Redundancy and Length - Two times read redundancy based on redundancy flags and\n\tcode length.\n\t* Security Short or Codabar - Two times read redundancy if short bar code or Codabar.\n\t* Security All Twice - Two times read redundancy for all bar codes.\n\t* Security Long and Short - Two times read redundancy for long bar codes, three times for short bar codes.\n\t* Security All Thrice - Three times read redundancy for all bar codes.\n* Picklist - Allows the imager to decode only the bar code that is directly under the cross-hair/reticle (+) part of the pattern. This feature is useful in applications where multiple bar codes may appear in the field of view during a decode session and only one of them is targeted for decode.\n\t* Disable – Disables Picklist mode. Any bar code within the field of view can be decoded.\n\t* Centered - Enables the Picklist mode so that only the bar code in the center of the image is decoded. This is most useful when used in conjunction with the static and dynamic reticle viewfinder modes. Note: This mode is only valid for decoder modules that supports a viewfinder. If one tries to set this for a unsupported decoder then the device would issue an error. (Camera scanner only).\n\t* Reticle - Enables the Picklist mode so that only the bar code that is directly under the cross-hair (reticle) is decoded. This is useful when used in conjunction with the static and dynamic reticle viewfinder modes. (Scan Module Only)\n* LCD Mode - Enables or disables LCD mode. LCD mode enhances the ability of the imager to read bar codes from LCD displays such as cellphones (Scan Module Only).\n\t* Disable - Disables the LCD mode. \n\t* Enable - Enables LCD mode.\n\n\tNOTE When using the LCD mode, a degradation in performance may be observed and the aiming crosshair may blink until the bar code is decoded.\n\n* Inverse 1D Mode - This parameter allows the user to select decoding on inverse 1D bar codes.\n\t* Disable - Disables decoding of inverse 1D bar codes.\n\t* Enable - Enables decoding of only inverse 1D bar codes.\n\t* Auto - Allows decoding of both positive and inverse 1D bar codes.\n* Viewfinder Mode - Configures the Viewfinder modes supported for camera scanning.\n\t* Viewfinder Enabled - Enables only the viewfinder.\n\t* Static Reticle - Enables the viewfinder and a red reticle in the center of the screen which helps selecting the bar code.\n\n### Scan Params\nAllows the configuration of Code Id and decode feedback options.\n\n* Code ID Type - A Code ID character identifies the code type of a scanned bar code. This is useful when the reader is decoding more than one code type. Select a code ID character to insert between the prefix and the decoded symbol.\n\t* Code ID Type None - No prefix (default).\n\t* Code ID Type Aim - A standards based three character prefix.\n\t* Code ID Type Symbol - A Symbol defined single character prefix.\n\t\n\tNOTE Not all ringtones are fully supported as decode tones. Ringtones of longer length may be truncated when used as a decode tone. The recommendation is to test the selected tone for operation before deployment to a customer site.\n\n* Decode Audio Feedback - Select an audio tone to sound upon a good decode.\n* Decode Haptic Feedback - Enable the MC40 to vibrate upon a good decode.\n\n## Output Data\nIn order for your application to receive the barcode data, you must specify one or more Output features. Please  refer to their reference documentation for more information.\n\n* [Intent](#guide-profiles-profileintent) \n* [Keystroke](#guide-profiles-profilekeystroke)\n"},{"key":"guide-profiles-profileintent","name":" Intent - Profile Reference","md":"# Intent - Profile Reference\n\n## Overview\nIn order to get Barcode or MSR data in your application, you must create a profile that has both an Input feature and an Output feature:\n\n* [Barcode](#guide-profiles-profilebarcode) / [MSR](#guide-profiles-profilemsr) (Input)\n* Intent or [Keystroke](#guide-profiles-profileintent) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed settings for scanner behavior as well as individual barcode symbology settings.\n\nThe `Intent` or `Keystroke` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n## Android Intent Overview\nThe core components of an Android application (its activities, services, and broadcast receivers) are activated by intents. An intent is a bundle of information (an Intent object) describing a desired action — including the data to be acted upon, the category of component that should perform the action, and other pertinent instructions. Android locates an appropriate component to respond to the intent, launches a new instance of the component if one is needed, and passes it the Intent object.\n\nComponents advertise their capabilities, the kinds of intents they can respond to, through intent filters. Since the system must learn which intents a component can handle before it launches the component, intent filters are specified in the manifest as &lt;intent-filter&gt; elements. A component may have any number of filters, each one describing a different capability.\n\nFor example, if the application manifest contains the following:\n\n\t:::xml\n\t<intent-filter . . . >  \n  \t\t<action android:name=”com.symbol.emdksample.RECVR” />  \n  \t\t<category android:name=”android.intent.category.DEFAULT” />  \n\t</intent-filter>\n\nIn the Intent Feature Profile configuration, the Intent action must be: \n\n\t:::java\n\tcom.symbol.emdksample.RECVR\n\nand the Intent category must be: \n\n\t:::java\n\tandroid.intent.category.DEFAULT\n\n\n## EMDK Intent Output\nAllows configuration of the Intent Feature for the profile. The Intent Output Feature allows the captured data to be sent to an application in the form of an implicit Intent. Refer to the Android Developer web site for more information, http://developer.android.com.\n\n* Enabled - Enables or disables this feature. \n* Intent action - Enter the Intent Action name (required). The Intent Filter action must match this.\n* Intent category - Enter the Intent Category name (required). The Intent Filter category must match this.\n* Intent delivery - Select the method by which the intent is delivered:\n\t* Send via StartActivity\n\t* Send via startService\n\t* Broadcast intent\n* Basic data formatting - Allows configuration of any data formatting. When disabled, any data is passed on without modification.\n\t* Enabled - Enables or disables Basic Data Formatting. \n\t* Prefix to data - Add characters to the beginning of the data when sent.\n\t* Suffix to data - Add characters to the end of the data when sent.\n\t* Send data - Set to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suffix strings, if present, are still transmitted even when this option is disabled (default - enabled).\n\t* Send as hex - Set to send the data in hexadecimal format. \n\t* Send TAB key - Set to append a tab character to the end of the processed data. \n\t* Send ENTER key - Set to append an Enter character to the end of the processed data. \n\n## EMDK Intent Return Parameters\nThe decode related data added to the Intent’s bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags:\n\n* `com.motorolasolutions.emdk.datawedge.label_type`: String contains the label type of the bar code.\n* `com.motorolasolutions.emdk.datawedge.data_string`:\nString contains the output data as a String. In the case of concatenated bar codes, the decode data is concatenated and sent out as a single string. In the case of MSR output, the data from the MSR tracks is concatenated and sent out as a single string.\n* `com.motorolasolutions.emdk.datawedge.decode_data`:\nDecode data is returned as a list of byte arrays. In most cases there will be one byte array per decode. For barcode symbologies that support concatenation e.g. Codabar, Code128, MicroPDF, etc., the decoded data is stored in multiple byte arrays (one byte array per bar code). Clients can get data in each byte array by passing an index.\n\nThe MSR related data added to the Intent's bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags:\n\n* `com.motorolasolutions.emdk.datawedge.msr_data`:\nThe data from the MSR tracks is concatenated and sent out as a byte array. The Start/end sentinels and\ntrack separators are included as configured.\n* `com.motorolasolutions.emdk.datawedge.msr_track1`: MSR track 1 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track2`: MSR track 2 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track3`: MSR track 3 data is returned as a byte array.\n* `com.motorolasolutions.emdk.datawedge.msr_track1_status`: MSR track 1 decode status as an Integer where 0 indicates a successful decode.\n* `com.motorolasolutions.emdk.datawedge.msr_track2_status`: MSR track 2 decode status as an Integer where 0 indicates a successful decode.\n* `com.motorolasolutions.emdk.datawedge.msr_track3_status`: MSR track 3 decode status as an Integer where 0 indicates a successful decode.\n\nMost scanning applications might want the user to be able to decode data and for that decode data to be sent to the *current* activity but not necessarily displayed. If this is the case, then the activity needs to be marked as ‘singleTop’ in its AndroidManifest.xml file. If your activity is not defined as singleTop, then on every decode, the system will create another copy of your Activity and send the decode data to this second copy.\n"},{"key":"guide-profiles-profilekeystroke","name":" KeyStroke - Profile Settings Reference","md":"# KeyStroke - Profile Settings Reference\n\n## Overview\nIn order to get Barcode or MSR data in your application, you must create a profile that has both an Input feature and an Output feature:\n\n* [Barcode](#guide-profiles-profilebarcode) / [MSR](#guide-profiles-profilemsr) (Input)\n* Intent or [Keystroke](#guide-profiles-profilekeystroke) (Output)\n\nThe `Barcode` feature in the Profile Manager is responsible for reading data from the device's integrated bar code scanner and supports different types of bar code readers including laser, imager and internal camera. It also contains detailed settings for scanner behavior as well as individual barcode symbology settings.\n\nThe `Intent` or `Keystroke` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n## Keystroke Output\nUse to configure the Keystroke Output Feature for the profile.\n\n* Enabled - Enables or disables this feature. \n* Action key character - Enabled decoding a special characters embedded within a bar code or MSR data.\n\t* None - Action key character feature is disabled (default).\n\t* Tab - Tab character (\\t) in a bar code is processed.\n\t* Line feed - Line feed character (\\t) in a bar code is processed.\n\t* Carriage return - Carriage return character (\\t) in a bar code is processed.\n* Basic data formatting - Allows the configuration of any data formatting. When disabled, any data is passed on without modification.\n\t* Enabled - Enables or disables Basic Data Formatting. \n\t* Prefix to data - Add characters to the beginning of the data when sent.\n\t* Suffix to data - Add characters to the end of the data when sent.\n\t* Send data - Set to transfer the captured data to the foreground application. Disabling this option prevents the actual data from being transmitted. However, the prefix and suffix strings, if present, are still transmitted even when this option is disabled (default - enabled).\n\t* Send as hex - Set to send the data in hexadecimal format. \n\t* Send TAB key - Set to append a tab character to the end of the processed data. \n\t* Send ENTER key - Set to append an Enter character to the end of the processed data. \n\n"},{"key":"guide-profiles-profilemsr","name":" MSR - Profile Settings Reference","md":"# MSR - Profile Settings Reference\n\n## Overview\nIn order to get MagStripe (MSR) data in your application, you must create a profile with two profile features selected:\n\n* MSR\n* Intent or Keystroke\n\nThe `MSR` feature in the Profile Manager is responsible for reading data from the device's integrated mag-stripe reader (if one such exists).\n\nThe `Intent` or `Keystroke` feature in the Profile Manager is used to define how the output from the Barcode scanner should be handled.\n\n* Intent - The Intent feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application using the Android Intent mechanism. To use this, you should be familiar with how to register to receive intents in your application as well as handling the data that is passed in. You will have the ability to configure how the intent is sent to your application in the profile itself.\n\n* Keystroke - The Keystroke feature, in the Profile Manager, collects and sends data received from the Barcode scanner to your application by emulating keystrokes. You will have the option to control how the data is sent as well as if it should have any prefix or suffix automatically added using basic data formatting.\n\n## MSR Settings Reference\n\n### Enabled\nEnables or disables this feature. Default is disabled.\n\n## Output Data\nIn order for your application to receive the barcode data, you must specify one or more Output features. Please  refer to their reference documentation for more information.\n\n* [Intent](#guide-profiles-profileintent) \n* [Keystroke](#guide-profiles-profilekeystroke)\n"},{"key":"guide-profiles-usingwizard","name":" Using EMDK for Android Profiles","md":"# Using EMDK for Android Profiles\n##EMDK Profiles Overview\n\nMotorola's EMDK for Android allows you to easily access various capabilities of your Motorola Android device from within an Android application. These settings are grouped together into, what is referred to as EMDK profiles. Each EMDK profile is broken into various feature types. Each profile feature type has settings to provide automatic enablement as well as configuration options that will control it's behavior. One such profile feature type is Data Capture, which allows you to accesses the devices bar code scanner and magstripe reader. \n\n##EMDK Feature Types\n\n###Data Capture\n\nEMDK Data Capture profiles allow you to access and configure a devices bar code scanner and magstripe reader, along with how the data captured should be transmitted to your application. There are typically three components that are used to make this work:\n\n* Activity Selector - Automatically activates the profile based on application & activity combinations.\n* Input Sources - Choose if Barcode & MSR is the source of the data.\n* Output Sources - Output the input source data as a Keystroke or Intent output.\n\n####Activity Selector\nThis feature allows you to select a combination of applications and activities that will be used to automatically activate this profile.\n\n![img](images/2.0/profiles/image018.jpg)\n\n####Data Capture Inputs\nCurrently there are Barcode and MSR methods for Data Capture. In the future, there may be other methods for capturing data like RFID, etc. Each Input type can be configured individually and should be accompanied with an Output feature in order for the data to be received by your application.\n\n* [Barcode](#guide-profiles-profilebarcode) - These settings allows you to select how the device should handle bar code scanning.\n* [MSR](#guide-profiles-profilemsr) - This setting allows you to enable magstripe reader input support. \n\n![img](images/2.0/profiles/image019.jpg)\n\n####Data Capture Outputs\nOnce data is captured using either Barcode or MSR, the data captured will not be delivered to your application unless you have a Data Capture output configured. Currently there are two options for outputting data:\n\n* [Intent](#guide-profiles-profileintent) - These settings allows you to select how data should be delivered to your application in the form of an intent. \n* [Keystroke](#guide-profiles-profilekeystroke) - These settings allows you to specify how data should be delivered to your app in the form of keystrokes.\n\n![img](images/2.0/profiles/image020.jpg)\n\n##Using the EMDK Profile Manager\n\nProfile Manager is an exclusive EMDK technology offered within the Eclipse IDE, providing a GUI based development tool. This allows you to write fewer lines of code resulting in reduced development time, effort and errors.  \n\n###Accessing the Profile Manager\n1. Inside the Eclipse ADT select an Android Application in the \"Package Explorer\".\n2. Select \"EMDK\" -> \"Profile Manager\" on the toolbar.  \n    ![img](images/2.0/profiles/image001.jpg)\n\n###Creating a Profile\n\n1. Open the \"EMDK Profile Manager\".  \n2. Click \"Create\".  \n    ![img](images/2.0/profiles/image002.jpg)\n\n3. Enter a Profile Name and click \"Create\".  \n\t![img](images/2.0/profiles/image003.jpg)  \n4. Select the features you would like to enable by selecting the item from the list of \"Available Features\" and clicking the right arrow button. \n\t>Note:  \n\t>\n\t> You must enable both a Data Capture feature and a Data Capture Input Feature for the profile to send data to your application. For example \"Barcode\" and \"Intent\".\n\t>\n\t> You can remove a feature from the \"Selected Features\" list by clicking the left arrow button.\n\t\n\t![img](images/2.0/profiles/image004.jpg)  \n5. Select a \"Selected Features\" and the list of settings will populate on the left hand side of the dialog. When click on a setting a description with populate on the lower left hand corner of the dialog.  \n\t![img](images/2.0/profiles/image005.jpg)  \n6. When complete click \"Finish\". \n7. Click \"Close\".  \n\t![img](images/2.0/profiles/image006.jpg)\n\n\t>Note:  \n\t>The profile XML will be generated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder.   \n\t\n###Editing a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to modify and click \"Edit\".  \n\t![img](images/2.0/profiles/image007.jpg)  \n3. Edit the profile using the Profile Manager in the same way you would when creating a new profile.\n4. When complete click \"Finish\".\n5. Click \"Close\".  \n\t![img](images/2.0/profiles/image008.jpg)\n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\t\n###Renaming a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to rename and click \"Rename\".  \n\t![img](images/2.0/profiles/image009.jpg)  \n3. Enter the new name and click \"Rename\";  \n\t![img](images/2.0/profiles/image010.jpg)  \n4. Click \"Close\".  \n\t![img](images/2.0/profiles/image011.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n###Copying a Profile\n\n1. Open the EMDK Profile Manager.\n2. Select a Profile to copy and click \"Copy\".  \n\t![img](images/2.0/profiles/image012.jpg)  \n3. Enter the a name profile name to uses and click \"Copy\";  \n\t![img](images/2.0/profiles/image013.jpg)  \n4. Click \"Close\".  \n\t![img](images/2.0/profiles/image014.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n\n###Deleting a Profile\n1. Open the EMDK Profile Manager.\n2. Select a Profile to delete and click \"Delete\".  \n\t![img](images/2.0/profiles/image015.jpg)  \n3. Confirm delete by clicking \"Delete\";  \n\t![img](images/2.0/profiles/image016.jpg)  \n4. Click \"Close\".  \n\t![img](images/2.0/profiles/image017.jpg)  \n\n\t>Note:  \n\t>The profile XML will be updated and saved to \"EMDKConfig.XML\" inside your projects \"assets\" folder. \n\n##Using the Profile Manager API\nOnce you create your profiles using the Profile Manager, they will be bundled with your application and available to access using the [Profile Manager APIs](#guide-reference-EMDKList).\n\n### Multiple Ways to Access\nIn the ProfileManager API, you will see three methods for `processProfile`. Essentially the last parameter, `extraData`, is one of three types:\n\n* **Document** - data will be handled as a XML Document.\n* **String** - data will be handled as a raw string.\n* **ProfileConfig** - data will be handled as a ProfileConfig class.\n\nThe preferred way is to use the `profileConfig` option and the examples below present using such option. Using the Document or String methods may not work if the XML is not structured properly.\n\n###Creating or Activating a Profile\nA profile is created or activated with using the PROFILE_FLAG.SET option. If the profileFlag is set to SET, and if the given profile is not available, it will look for valid profile in extraData argument and if present, the profile  will be added to the internal XML volatile repository and also applied to the device.  If the profile is present, then it will be applied to the device. \n\n\t:::java\n\t@Override  \n    public void onOpened(EMDKManager emdkmanager)  \n    {  \n        //Create the Profile Config object  \n        ProfileConfig profileConfigObj = new ProfileConfig();  \n       \n        //Get the Profile Manager  \n        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n       \n        //Create the new profile  \n        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.SET, profileConfigObj);     \n    }  \n\n###Getting a Profile\nIf profileFlag is set to GET and if the profile is present in the internal repository, it will be returned in the extraData object.\n\n\t:::java\n\t@Override  \n    public void onOpened(EMDKManager emdkmanager)  \n    {  \n        //Create the Profile Config object  \n        ProfileConfig profileConfigObj = new ProfileConfig();  \n       \n        //Get the Profile Manager  \n        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n       \n        //Get the profile and store it in the ProfileConfig object  \n        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);         \n    }  \n\n###Modifying a Profile\nTo modify a profile, you would:\n\n* Use the PROFILE_FLAG.GET option to retrieve the profile (if it exists).\n* Use the profileConfig Object and APIs to modify the settings.\n* Use the PROFILE_FLAG.SET option to save the settings.\n\n\n\t \t:::java\n\t \t@Override  \n\t    public void onOpened(EMDKManager emdkmanager)  \n\t    {  \n\t        //Create the Profile Config object  \n\t        ProfileConfig profileConfigObj = new ProfileConfig();  \n\t       \n\t        //Get the Profile Manager  \n\t        ProfileManager profileManager = (ProfileManager)emdkmanager.getInstance(FEATURE_TYPE.PROFILE);  \n\t       \n\t        //Get the profile and store it in the ProfileConfig object  \n\t        EMDKResults results = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.GET, profileConfigObj);  \n\t        //Enable MSR  \n\t        profileConfigObj.dataCapture.msr.msr_input_enabled = ENABLED_STATE.TRUE;  \n\t        //Modify Profile  \n\t        EMDKResults ModifyResults = profileManager.processProfile(\"ProfileName\", ProfileManager.PROFILE_FLAG.SET, profileConfigObj);  \n\t    }  "},{"key":"guide-reference-EMDKList","name":"EMDK For Android API List","md":"#EMDK For Android API List\n\n* [EMDKManager](#api-EMDKManager) \n* [EMDKManager.EMDKListener](#api-EMDKManager-EMDKListener) \n* [EMDKResults](#api-EMDKResults) \n* [ProfileManager](#api-ProfileManager) \n* [VersionManager](#api-VersionManager) \n* [ProfileConfig](#api-ProfileConfig)\n* [ProfileConfig.ActivitySelection](#api-ProfileConfig-ActivitySelection) \n* [ProfileConfig.ActivitySelection.ActivityElement](#api-ProfileConfig-ActivitySelection-ActivityElement) \n* [ProfileConfig.DataCapture](#api-ProfileConfig-DataCapture) \n* [ProfileConfig.DataCapture.Barcode](#api-ProfileConfig-DataCapture-Barcode) \n* [ProfileConfig.DataCapture.Barcode.Decoders](#api-ProfileConfig-DataCapture-Barcode-Decoders) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams](#api-ProfileConfig-DataCapture-Barcode-DecoderParams) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Codabar](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Codabar) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code11](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code11) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code128](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code128) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code39](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code39) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Code93](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Code93) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Composite_AB](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Composite_AB)\n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Discrete_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Discrete_2of5)\n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Interleaved_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Interleaved_2of5) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.Matrix_2of5](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-Matrix_2of5) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.MSI](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-MSI) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UK_Postal](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UK_Postal) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCA](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCA) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE0](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE0) \n* [ProfileConfig.DataCapture.Barcode.DecoderParams.UPCE1](#api-ProfileConfig-DataCapture-Barcode-DecoderParams-UPCE1) \n* [ProfileConfig.DataCapture.Barcode.ReaderParams](#api-ProfileConfig-DataCapture-Barcode-ReaderParams) \n* [ProfileConfig.DataCapture.Barcode.ScanParams](#api-ProfileConfig-DataCapture-Barcode-ScanParams) \n* [ProfileConfig.DataCapture.Barcode.UpcEanParams](#api-ProfileConfig-DataCapture-Barcode-UpcEanParams) \n* [ProfileConfig.DataCapture.MSR](#api-ProfileConfig-DataCapture-MSR) \n* [ProfileConfig.DataCapture.DataDelivery](#api-ProfileConfig-DataCapture-DataDelivery) \n* [ProfileConfig.DataCapture.DataDelivery.BasicDataFormatting](#api-ProfileConfig-DataCapture-DataDelivery-BasicDataFormatting) \n* [ProfileConfig.DataCapture.DataDelivery.Intent](#api-ProfileConfig-DataCapture-DataDelivery-Intent) \n* [ProfileConfig.DataCapture.DataDelivery.Keystroke](#api-ProfileConfig-DataCapture-DataDelivery-Keystroke)\n\n"},{"key":"guide-reference-refbatteryintent","name":" Battery Intent API Reference","md":"# Battery Intent API Reference\n\n## Overview\nThe purpose of this document is to describe the functionality of the Battery Intent API Interface. Its intended audience are Android developers. \n \n## Requirements\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. \n \n* Android Versions:\t\n\t* 2.3.4 and later.\n* Devices:\t\n\t* Motorola Solutions Android devices, such as the ET1 rev D, MC40 rev A.\n \n \n## Features\nOn Motorola Solutions Android devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery\n \n## Programming Interface\n \n#### Function Prototype\n\t\n\t:::java\n\tmIntent_Receiver = new Intent_Receiver();  \n\tmIntentFilter = new IntentFilter();  \n\tmIntentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);  \n\tregisterReceiver(mIntent_Receiver,mIntentFilter); \n\n#### Parameters\n\nPlease reference the Android Batter Manager [API](http://developer.android.com/reference/android/os/BatteryManager.html). \n\n#### Return Values\n\nIn addition to the battery information Android returns by default, which can be found [here](http://developer.android.com/reference/android/os/BatteryManager.html), Motorola Solutions Android devices return the following additional parameters: \n\n* **bkvoltage** - Backup Battery Voltage\n* **mfd**  - Battery Manufacture Date\n* **serialnumber** - Battery Serial Number\n* **partnumber** - Part Number for Battery\n* **uniqueid** - Unique ID for Battery\n* **ratedcapacity** - Rated Capacity of the Battery\n* **cycle** - Charge Cycle count of the Battery\n\n#### Example\n\n\t:::java\n\tpublic void onReceive(Context context, Intent intent) {      \n\t\tif (BATTERY_STATE_CHANGED_INTENT.equals(intent.getAction())) {          \n\n\t\t\tint bkvoltage = intent.getExtras().getInt(\"bkvoltage\");  \n\t\t\tString mfd = intent.getExtras().getString(\"mfd\");  \n\t\t\tString serialnumber = intent.getExtras().getString(\"serialnumber\");  \n\t\t\tString partnumber = intent.getExtras().getString(\"partnumber\");  \n\t\t\tString uniqueid = intent.getExtras().getString(\"uniqueid\");  \n\t\t\tint ratedcapacity = intent.getExtras().getInt(\"ratedcapacity\");  \n\t\t\tint cycle = intent.getExtras().getInt(\"cycle\");  \n\t\t     \n\t\t}  \n\t} \n"},{"key":"guide-reference-refdatacaptureintent","name":" Data Capture Intent API Reference","md":"# Data Capture Intent API Reference\n## Overview\nThe purpose of this document is to describe the functionality of the Data Capture API. Its intended audience are Android developers. The Data Capture API is an application programming interface which provides a number of specific commands that another application can use to control certain aspects of data capture on Motorola Solutions Android devices.\n \n## Requirements\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. Also assumed is some familiarity with DataWedge and that you have read the DataWedge section in the Integrator Guide for your device.\n \n* Android Versions:\t\n\t* 2.3.4 and later\n* Devices:\t\n\t* ET1 rev D, MC40 rev A, TC55, etc.\n \n \n## Features\nThe following is a list of the high-level API functions…\n\n* Start/stop/toggle the soft scan trigger.\n* Disable/enable the scanner plug-in in the currently active profile.\n* Provide a list of available scanners.\n* Make an un-associated user created profile the default profile.\n* Reset the default profile back to Profile0.\n* Switch the current profile to a user created profile that is un-associated.\n \n## DataWedge Profiles\nThe DataCapture APIs use the DataWedge profiles for collecting and formatting data.  For example, each user application can have a profile which outputs scanned data in the required format when that application comes to the foreground. DataWedge can be configured to process the same set of captured data differently based on the requirements of each application.  Refer to the DataWedge section in your devices Integrator Guide for more information on DataWedge profiles.\n \n## Programming Interface\nAn application will access the Data Capture API by broadcasting an intent. It will use the primary pieces of information in a intent, action and data, to specify the API function to perform.\n \n### SoftScanTrigger\n#### Description\nThe SoftScanTrigger API command can be used to start, stop or toggle the soft scan trigger.\n \n \n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<parameter>\");\n\n#### Parameters\n\n* ACTION: String \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\"\n* EXTRA_DATA: String \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\"\n* <parameter>:\tThe parameter as a string, either of the following…\n\t* \"START_SCANNING\" - to start scanning\n\t* \"STOP_SCANNING\" - to stop scanning\n\t* \"TOGGLE_SCANNING\" - to toggle between start scanning and stop scanning\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString softScanTrigger = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n\t  \n\t// create the intent  \n\tIntent I = new Intent();  \n\t// set the action to perform  \n\ti.setAction(softScanTrigger);  \n\t// add additional info  \n\ti.putExtra(extraData, \"START_SCANNING\");  \n\t// send the intent to DataWedgecontext.this.sendBroadcast(i);  \n\n#### Comments\nThe received API commands are not queued; API commands are processed immediately. Commands received while the current API command is still being processed may be ignored. For example, attempting to send the soft scan trigger start command immediately after sending the scanner enable command will result in the soft scan trigger command being ignored because the scanner enable will not have had time to complete. In this case, the soft scan trigger command should be delayed sufficiently for the scanner enable to complete; one example of how this could be done is given below.\n\n\t:::java\n\tint triggerDelay = 250; // delay in milliseconds  \n\t  \n\tHandler handler = new Handler();  \n\thandler.postDelayed(new Runnable() {       \n\t      public void run()  \n\t      {               \n\t          // for clarity, assume the following method contains the code in the example above               \n\t          startSoftScan();       \n\t      }  \n\t}, triggerDelay);  \n\n### ScannerInputPlugin\n#### Description\nThe ScannerInputPlugin API command can be used to enable/disable the scanner plug-in in the currently active profile. Disabling the scanner plug-in effectively disables scanning in that profile (associated or un-associated).\n \n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<parameter>\"); \n\n#### Parameters\n\n* ACTION: String \"com.motorolasolutions.emdk.datawedge.api.ACTION_SCANNERINPUTPLUGIN\"\n* EXTRA_DATA: String \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\"\n* <parameter>:\tThe parameter as a string, either of the following…\n\t* \"ENABLE_PLUGIN\" - enables the plug-in\n\t* \"DISABLE_PLUGIN\" - disables the plug-in\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString scannerInputPlugin = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SCANNERINPUTPLUGIN\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(scannerInputPlugin);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"DISABLE_PLUGIN\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\nThis Data Capture API intent will allow you to enable/disable the scanner plug-in for the current profile. For example, let’s say that activity A launches and uses the Data Capture API intent to switch to profileA in which the scanner plug-in is enabled, then at some point it uses the Data Capture API to disable the scanner plug-in. Activity B is launched. In DataWedge, profileB is associated with activity B. DataWedge switches to profileB. When activity A comes back to the foreground, in the onResume method, activity A will need to use the Data Capture API intent to switch back to profileA, then use the Data Capture API intent again to disable the scanner plug-in, to return back to the state it was in.\n\n>Note\n>The above assumes that profileA is not associated to any applications/activities, therefore when focus switches back to activity A, DataWedge will not automatically switch to profileA therefore activity A must switch back to profileA in its onResume method.\n>Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n\n### enumerateScanners\n#### Description\nThe enumerateScanners API command can be used to get a list of scanners available on the device.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATESCANNERS\"\n\n#### Return Values\n* The enumerated list of scanners will be returned via a broadcast intent. The broadcast intent action is \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATEDSCANNERLIST\" and the list of scanners is returned as a string array (see the example below).\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions and parameters\n\n#### Example\n\n\t:::java\n\t// first send the intent to enumerate the available scanners on the device  \n\t// define action string  \n\tString enumerateScanners = \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATESCANNERS\";  \n\t// create the intent  \n\tIntent I = new Intent();  \n\t// set the action to perform  \n\ti.setAction(enumerateScanners);  \n\t// send the intent to DataWedge  \n\tcontext.this.sendBroadcast(i);// now we need to be able to receive the enumerate list of available scanners  \n\tString enumeratedList = \"com.motorolasolutions.emdk.datawedge.api.ACTION_ENUMERATEDSCANNERLIST\";  \n\tString KEY_ENUMERATEDSCANNERLIST = \"DataWedgeAPI_KEY_ENUMERATEDSCANNERLIST\";  \n\t// Create a filter for the broadcast intentIntentFilter filter = new IntentFilter();  \n\tfilter.addAction(enumeratedList);registerReceiver(myBroadcastReceiver, filter);// now we need a broadcast receiver  \n\tprivate BroadcastReceiver myBroadcastReceiver = new BroadcastReceiver() {       \n\t      @Override        Public void onReceive(Context context, Intent intent) {               \n\t          String action = intent.getAction();               \n\t          if (action.equals(enumeratedList)) {                       \n\t                Bundle b = intent.getExtras();                       \n\t                String[] scanner_list = b.getStringArray(KEY_ENUMERATEDSCANNERLIST);               \n\t          }       \n\t      }  \n\t};  \n\n#### Comments\nThe scanner and its parameters are set based on the currently active profile.\n\n### setDefaultProfile\n#### Description\nThe setDefaultProfile API function can be used to set the specified profile as the default profile.\n\n#### Default Profile Recap\nProfile0 is the generic profile used when there are no user created profiles associated with an application. Profile0 can be edited but cannot be associated with an application. That is, DataWedge allows manipulation of plug-in settings for Profile0 but it does not allow assignment of a foreground application.\n\nThis configuration allows DataWedge to send output data to any foreground application other than applications associated with user-defined profiles when Profile0 is enabled.\n\nProfile0 can be disabled to allow DataWedge to only send output data to those applications which are associated in user-defined profiles. For example, create a profile associating a specific application, disable Profile0 and then scan. DataWedge only sends data to the application specified in the user-created profile. This adds additional security to DataWedge enabling the sending of data only to specified applications.\n\n#### usage Scenario\nLet’s say a launcher application has a list of apps that a user can launch and that none of the listed apps has an associated DataWedge profile. Once the user has selected an app, the launcher needs to set the appropriate DataWedge profile for the selected app. This could be done by using setDefaultProfile to set the default profile to the required profile. Then when the user selected app is launched, DataWedge auto profile switching will switch to the default profile (which is now the required profile for that app).\n\nIf, for some reason, the launched app has an associated DataWedge profile then that will override the set default profile.\n\nWhen control is returned to the launcher application, resetDefaultProfile can be used to reset the default profile.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");\n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_SETDEFAULTPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* <profile name>:\tThe profile name to set as the default profile as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString setDefaultProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SETDEFAULTPROFILE\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(setDefaultProfile);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"myProfile\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n\n* The API command will have no effect if the specified profile does not exist or if the specified profile is already associated to an application.\n* Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n* It is recommended this profile be created to cater to all applications/activities that would otherwise default to using Profile0. This will ensure that these applications/activities continue to work with a consistent configuration.\n\nTo explain by example, let’s say that initially Profile0 is the default profile using the camera as the barcode scanner. Using the Browser application and scanning a barcode with the camera, DataWedge enters the data into the Browser. Now you launch an application that changes the default profile to a profile using the blockbuster as the barcode scanner. When you go back to the Browser application, since it is using the default profile, scanning will now be via the blockbuster not the camera as previously. To ensure that the Browser continues to use the camera as the barcode scanner a profile should be created and associated to the Browser that specifies the camera as the barcode scanner.\n\n### resetDefaultProfile\n#### Description\nThe resetDefaultProfile API function can be used to reset the default profile back to Profile0.\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");\n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_RESETDEFAULTPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* <profile name>:\tThe profile name to set as the default profile as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action string  \n\tString resetDefaultProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_RESETDEFAULTPROFILE\";  \n\t  \n\tpublic void onResume() {       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(resetDefaultProfile);       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n\n* None.\n\n### switchToProfile\n\n#### Description\nThe switchToProfile API action can be used to switch to the specified profile.\n\n#### Profiles Recap\nDataWedge is based on profiles and plug-ins. A profile contains information on how DataWedge should behave with different applications.\n\nProfile information consists of:\n\n* Associated application\n* Input plug-in configurations\n* Output plug-in configurations\n* Process plug-in configurations\n\n\nDataWedge includes a default profile, Profile0, that is created automatically the first time DataWedge runs.Using profiles, each application can have a specific DataWedge configuration. For example, each user application can have a profile which outputs scanned data in the required format when that application comes to the foreground. DataWedge can be configured to process the same set of captured data differently based on the requirements of each application.\n\n>Note\n>A single profile may be associated with one or many activities/apps, however, given an acitivty, only one profile may be associated to it.\n\n#### Usage Scenario\nLet’s say an application has two activities. ActivityA only requires EAN13 barcodes to be scanned. ActivityB only requires MSR card data. ProfileB is configured to only scan EAN13 barcodes and is left unassociated. ProfileM is configured to only accept MSR input and is left unassociated. When ActivityA launches it uses switchToProfile to activate ProfileB. Similarily, when ActivityB launches it uses switchToProfile to activate ProfileM.\n\nIf another activity/app comes to the foreground, DataWedge auto profile switching will set the DataWedge profile accordingly either to the default profile or to an associated profile.\n\nWhen ActivityA (or ActivityB) comes back to the foreground it will use switchToProfile to reset the profile back to ProfileB (or ProfileM).\n\n#### Function Prototype\n\n\t:::java\n\tIntent i = new Intent();  \n\ti.setAction(ACTION);  \n\ti.putExtra(EXTRA_DATA, \"<profile name>\");  \n\n#### Parameters\n\n* ACTION:\tString \"com.motorolasolutions.emdk.datawedge.api.ACTION_SWITCHTOPROFILE\"\n* EXTRA_DATA:\tString \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\"\n* <profile name>:\tThe profile name to switch to as a string (case-sensitive).\n\n#### Return Values\n\n* None.\n* Error and debug messages will be logged to the Android logging system which then can be viewed and filtered by the logcat command. You can use logcat from an ADB shell to view the log messages, e.g.\n\t* $ adb logcat -s DWAPI\n* Error messages will be logged for invalid actions, parameters and failures (e.g. profile not found or associated to an application).\n\n#### Example\n\n\t:::java\n\t// define action and data strings  \n\tString switchToProfile = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SWITCHTOPROFILE\";  \n\tString extraData = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PROFILENAME\";  \n\t  \n\tpublic void onResume() {       \n\t    super.onResume();       \n\t    // create the intent       \n\t    Intent I = new Intent();       \n\t    // set the action to perform       \n\t    i.setAction(switchToProfile);       \n\t    // add additional info       \n\t    i.putExtra(extraData, \"myProfile\");       \n\t    // send the intent to DataWedge       \n\t    context.this.sendBroadcast(i);  \n\t}  \n\n#### Comments\n* This API function will have no effect if the specified profile does not exist or if the specified profile is associated to an application.\n* DataWedge has a one-to-one relationship between profiles and activities, i.e. only one profile can be associated to any given activity. When a profile is initially created, it is not associated to any application. Until this profile is associated to an activity it will never be activated. In this way it is possible to create multiple profiles that are un-associated.\n* This API function allows you to switch to one such unassociated profile.\n\nFor example, let’s say that ProfileA is one such un-associated profile and ProfileB is associated with activity B. Now, activity A is launched and uses this Data Capture API intent to switch to profileA. ProfileA will be active whilst activity A is in foreground. When another activity, say activity B, comes to the foreground DataWedge will automatically switch profile (to profileB which is associated to activity B for example). Then when activity A comes back to the foreground again, the app will need to use this Data Capture API intent to switch back to profileA. This would be done in the onResume method of activity A.\n \n> Note: Because DataWedge will automatically switch profile when your activity is paused, it is recommended that this API function be called from the onResume method of your activity.\n\n> Note: After switching to a profile, this un-associated profile does not get assigned to the application/activity and is available to be used in the future with a different app/activity.\n\n> Note: DataWedge automatic profile switching\n\nFor backward compatibility, DataWedge’s automatic profile switching is not affected by the above API commands, and this also why the above API commands only work with unassociated profiles and apps.\n\nDataWedge auto profile switching works as follows:\n\n* Every second:\n\t1. Set newProfileId to the associated profile id of the current foreground activity\n\t2. If no associated profile found then set newProfileId to the associated profile id of the current foreground app\n\t3. If no associated profile found then set newProfileId to the current default profile (note: this may not be Profile0)\n\t4. Check the newProfileId against the currentProfileId\n\t5. If they are different then…\n\t\t* deactivate current profile\n\t\t* activate new profile (newProfileId)\n\t\t* set currentProfileId = newProfileId"},{"key":"guide-reference-refnativeandroid","name":" Using Native Android APIs","md":"# Using Native Android APIs\n\n## Overview\nMotorola Solutions offers Android products that are built on Android Open Source Platform (AOSP). Two variants are now being offered on the TC55 and planned for certain future products.\n\n### \"Standard Configuration\"\nThis version of the operating system incorporates Google Mobile Services. All standard Google API's are available to use in your application. Please consult [http://developer.android.com](http://developer.android.com) for details of using these APIs. Your application also has access to the [EMDK For Android APIs](#guide-reference-EMDKList) as well.\n\n### \"Professional Configuration\" \nThis version of the operating system does not incorporate Google Mobile Services. Standard Google APIs that doe not rely on the availability of GMS services will work on our devices. Please consult [http://developer.android.com](http://developer.android.com) for details of using these APIs. Your application also has access to the [EMDK For Android APIs](#guide-reference-EMDKList) as well.\n\n## About GMS\nGoogle offers a variety of applications and services collectively known as Google Mobile Services (GMS). There are also optional Android API extensions that allow applications to interface with said services. GMS is independent of Android and under a separate license from Google. GMS runs as an add-on above AOSP (Android Open Source Platform)\n\n### GMS Applications and Services\n\n* Google Maps\n* Google Play Services\n* Google Cloud Messaging\n* Google Analytics\n* Google+\n* Google Mail - Gmail\n* Google Cloud Platform\n* Google Wallet Instant Buy\n* Google Play In-App Billing\n* Google Mobile Ads\n* Google Drive\n* Google Cast\n\n### Challenges with GMS\nCareful considering should be made when deciding if your application requires the use of GMS.\n\n* Security \n\t* Google Mobile Services requires devices to be identified with a specific GoogleID. \n\t* Any enterprise data (Gmail, Maps, Cloud etc) will be pushed through Google’s servers.\n\t* Gmail content is read by Google servers to improve relevance of advertisements.\n* Privacy\n\t* Google revamped their privacy policy in early 2012 allowing for richer user profiling across all services, for targeted advertising.\n\t* Usage acceptance allows Google to track a device’s every move.\n\t* Google may collect IP Addresses, location, nearby Wi-Fi info, local storage and device setting details.  \n* Configuration\n\t* Extra manual steps may be required to be performed when the device boots up for the first time. \n\n### GMS Alternatives\nDepending on the feature your application requires, you my want to consider alternative choices before declaring that your application requires GMS. \n\n* Mapping\n\t* Consider cloud based mapping solutions like MapQuest or OpenStreetMap.\n\t* Consider alternative device resident solutions like ALK CoPilot, Sygic and Tele Atlas to name a few.\n* Push Messaging\n\t* Consider cross-platform solutions like RhoConnect.\n\t* Consider other cloud based messaging providers like Parse, Amazon SNS, Pushwoosh and others.\n* Play Store\n\t* Consider MDM solutions for application distribution.\n\t* Consider cross-platform solutions like RhoGallery.\n"},{"key":"guide-sample-samplebatteryintent","name":" Battery - Intent Sample","md":"# Battery - Intent Sample\n\n## Overview\nOn Motorola Solutions Android devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery\n \n## Using This Sample\nYou may choose to install the Battery Sample Application.apk or to run the project from Eclipse:\n\n1. Download the battery sample application zip. \n2. Unzip the battery sample application zip.\n3. Start the Android ADT or compatible eclipse environment. \n4. Import the sample application. \n\t>How to import:  \n \t>1. Go to \"File\" -> \"Import\"  \n \t>![img](images/2.0/FileImport.jpg)   \n \t>2. Select \"Android\" -> \"Existing Android Code Into Workspace\" -> \"Next\"   \n \t>![img](images/2.0/ImportNext.jpg)   \n \t>3. Select \"Browse\" and navigate to your unzipped battery sample application folder.  \n \t>![img](images/2.0/Browse.jpg)  \n \t>4. Select \"Finish\".  \n \t>![img](images/2.0/Finish.jpg)  \n\n5. Run the sample application. \n\t>How to run the sample application:   \n \t>1. Select the sample application folder in \"Package Explorer\".      \n \t>2. Right click and select \"Run As\" -> \"Android Application\"  \n \t>![img](images/2.0/RunAs.jpg)   \n\n6. The battery sample application should look like the following:  \n\n![img](images/2.0/BatterySampleApplication.jpg)  \n\n7. The information on the screen will update each time a battery intent is received. To force the intent you may change power state of the device by charging or unplugging it from a power source.\n\n\n## How This Sample Was Built \nA [Tutorial](#guide-tutorial-tutbatteryintent) walks through how this sample application was built. \n\n## Download\nThe project [source](https://s3.amazonaws.com/emdk/Tutorials/BatterySampleApplication.zip) and [application](https://s3.amazonaws.com/emdk/Tutorials/BatterySampleApplication.apk.zip) to this tutorial can be downloaded (Internet Connection Required).\n<a name=\"theend\"></a>\n"},{"key":"guide-sample-sampledatacaptureintent","name":" Data Capture - Intent Sample","md":"# Data Capture - Intent Sample\n\n## Overview\nThis sample demonstrates how to use the DataWedge Intent output plug-in and the [Data Capture Intent API](#guide-reference-refdatacaptureintent) to receive captured data in your native Android application. \n\nA [Tutorial](#guide-tutorial-tutdatacaptureintent) walks through how this sample application was built from scratch. If you would simply like to see the application run on your device, follow the instructions in the next section.\n\n## Using This Sample\n\n1. Download DataCaptureDemoSource.apk to your computer\n2. Copy the APK from your computer to a Motorola Solutions Android device like a MC40 (using USD file copy or ADB)\n3. From the device, launch the File Manager application and click on the APK file you just copied to install the DWDemoSample application.\n4. On the device, Launch DataWedge\n5. Create a new profile and give it a name such as \"dwdemosample\"\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/2.png)\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/4.png)\n6. Edit the profile\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/5.png)\n7. Go into Associated apps, tap the menu button, and add a new app/activity\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/7.png)\n8. For the application select com.motorolasolutions.emdk.sample.dwdemosample\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/8.png)\n9. For the activity select com.motorolasolutions.emdk.sample.dwdemosample.MainActivty\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/9.png)\n10. Go back and disable the keystroke output plug-in\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/11.png)\n11. Enable the intent output plug-in\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/12.png)\n12. For the intent action enter com.motorolasolutions.emdk.sample.dwdemosample.RECVR\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/18.png)\n13. For the intent category enter android.intent.category.DEFAULT\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/14.png)\n14. Launch the DataWedge Demo Sample application\n\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/17.png)\n15. Press the back button to clear the keyboard\n16. Press the scan trigger on the device and scan a printed barcode\n17. Notice that the output displays the barcode data preceded with additional info (source, symbology and length) that is handled by the handleDecodeData() Intent receiver method.\n\t![img](https://s3-us-west-1.amazonaws.com/launchpad-images/2.0/emdk/SampleDataIntent/20.png)\n\n## Download\nThe project [source](https://s3.amazonaws.com/emdk/Tutorials/DataCaptureDemoSource.zip) and [application](https://s3.amazonaws.com/emdk/Tutorials/DataCaptureDemoApp.apk.zip) to this tutorial can be downloaded (Internet Connection Required).\n\n<a name=\"theend\"></a>\n\n\n\n"},{"key":"guide-sample-sampledatacaptureprofile","name":" Data Capture - Profile Manager Sample","md":"# Data Capture - Profile Manager Sample\n\n##EMDK Sample Walk Through##\n\nThis guide will walk you through using the EMDK sample Applications on your Motorola Android device. \n\n###Prerequisites###\n- Java JDK \n- Android ADT \n- Motorola EMDK  \n- An EMDK supported Motorola Android device\n\nFor more information about setting up the EMDK please see the [EMDK Overview](#guide-about).\n\n##Loading the Sample Application##\n\n1. Sample Applications are installed along with the EMDK and can be found in your start bar. \n\t1. Select Start \n\t2. Select \"Motorola EMDK for Android v2.0\"\n\t3. Select \"Samples\"\n\n\t\t  ![img](images/2.0/sample/1.jpg)\n\t4. Your browser should open with a list of included samples\n\n\t\t  ![img](images/2.0/sample/2.jpg)\n\t5. Select \"ADTSamples\" from the web page   \n\n\t\t  ![img](images/2.0/sample/3.jpg)\n\t6. Copy the path to the directory on your computer   \n\n\t\t  ![img](images/2.0/sample/4.jpg)\n\n2. In Eclipse select From the tool bar \"File\" -> \"Import\"\n3.  Select Android \"Existing Android Code Into Workspace\"\n\n    ![img](images/2.0/sample/5.jpg)\n4. Browse to the samples directory from the web page and select \"ProfileDataCaptureSample1\"\n\n    ![img](images/2.0/sample/6.jpg)\n5. Select Finish\n\n##Deploying a Sample Application##\n\n1. Attach an EMDK supported Motorola Android device to your computer in USB debug mode. \n\n\t>NOTE: The device needs the EMDK runtime installed.\n2. From the Package Explorer right click on the select the sample application \n3. Right click on the project and select \"Run As\" -> \"Android Application\"\n\n\t![img](images/2.0/sample/7.jpg)\n4. Select your Android device and click \"Okay\". \n    \n    ![img](images/2.0/sample/8.jpg)\n\n##About the Sample Application##\nWhen the application first loads you will see:\n\n* Checkboxes for changing Barcode options\n* A text area where Barcode data will be displayed\n* A Status area where status will be shown\n\n![img](images/2.0/sample/9.png)\n\n\n### Application Startup\nUsing the Profile Manager Wizard, a profile called 'DataCaptureprofile-1' was created. You can inspect the settings it has by launching the EMDK Profile Manager from Eclipse\n\n![img](images/2.0/sample/10.jpg)\n\nYou will see that the MainActivity for the application has been selected to indicate when this profile will be used.\n\n![img](images/2.0/sample/11.jpg)\n\nThe profile settings that have been chosen can be inspected to see that certain barcode decoders have been enabled and the output will be using the Keystroke feature. This profile has MSR and Intent output disabled.\n\n![img](images/2.0/sample/12.jpg)\n\n![img](images/2.0/sample/13.jpg)\n\n![img](images/2.0/sample/14.jpg)\n\nWhen the application starts up, the onOpened method is executed and the profile is processed.\n\n![img](images/2.0/sample/15.jpg)\n\n![img](images/2.0/sample/16.jpg)\n\nIt if was successful, you will see \"Profile initialization Success\" on the application's status area.\n\n![img](images/2.0/sample/17.png)\n\n### Scanning a Barcode\nAfter the application has been loaded, you can begin scanning barcodes. Notice that only Code128, EAN8, UPCA types have been chosen. When you press the scan trigger on the device, you should see the default scanner become activated and a barcode is attempted to be read. If the barcode you have chosen is not one of the ones listed above, it will not decode and display in the text area. \n\n>NOTE: Most everyday items you may have in your home use the UPCA type barcode. You may also Google these types of barcode to see what they look like and print one out for testing\n\nUpon successful Barcode scanning, the barcode data will be output into the text field.\n\n![img](images/2.0/sample/18.png)\n\n### Changing Barcode Settings\nWhen you uncheck the checkboxes in the application, the DataCaptureProfile-1 is modified on the fly using the ProfileConfig API. \n\n* Uncheck the barcode type you just scanned in \n* tap 'Set' and you should see 'Profile update success' in the status area\n\n![img](images/2.0/sample/19.png)\n\nNow when you scan the same Barcode, you will still see the barcode aimer but the data will not be decoded and you will not see the data displayed in the text area.\n\n## Next Steps\nNow that you have played with a pre-built sample application, it is time to try and build your own application from scratch. Follow the steps in the [DataCapture Profile Manager Tutorial](#guide-tutorial-tutdatacaptureprofile).\n\n"},{"key":"guide-setup","name":" EMDK For Android Setup","md":"# EMDK For Android Setup\n\n## Overview\n\nThe EMDK for Android provides the interface to Motorola value adds such as scanning and magstripe for developing Enterprise applications on Motorola Android devices.\nThis document is a guide to start working with Android Developer Tools (ADT)/Eclipse IDE environment for \"Motorola EMDK for Android\" development. \n\n##Configuring Development Computer\n\n### Installing Java Development Kit (JDK)\n1.\tGo to [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).\n2.\tDownload and install JDK v7u45 or newer. \n\n### Installing Android Developer Tools (ADT)\n1.\tGo to [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html \"http://developer.android.com/sdk/index.html\").\n2.\tClick \"Download the SDK\" button.\n3.\tAccept the License Agreement and Select the PC's architecture (32-bit or 64-bit).\n4.\tClick \"Download the SDK ADT Bundle for Windows\" button.\n5.\tExtract the downloaded ADT Bundle (ex. adt-bundle-windows-x86-20140321.zip) to any desired location.\n\n\t>NOTE:  \n\t>EMDK for Android requires ADT v22.3.0-887826 or higher version.\n\n### Configuring the Android Developer Tools (ADT) for EMDK\nThe EMDK requires Android API's 16 and 19 to be Installed.\n\nTo check which API's you have installed:\n\n1. In Eclipse go to \"Window\" -> \"Android SDK Manager\"\n2. Check that the status of \"Android 1.1.2 (API 16)\" and \"Android  4.4.2 (API 19)\" SDK Platforms status is \"Installed\". \n3. If either SDK platform is not installed check the SDK check mark, click \"Install Packages\", and follow the on screen instructions. When the install is complete restart Eclipse. \n\n\n### Installing EMDK for Android\n1.\tGo to [https://portal.motorolasolutions.com/Support/US-EN](https://portal.motorolasolutions.com/Support/US-EN \"https://portal.motorolasolutions.com/Support/US-EN\").\n2.\tSearch \"Motorola EMDK for Android\" using the Search Support.\n3.\tDownload and install Motorola EMDK for Android v2.0 or higher version.\n4. \tDuring installation, it will ask to specify the preferred Android development environment.\nThis can be either the Android Developer Tools (ADT) Bundle or the existing Eclipse IDE and the Android SDK (installed separately).  \n\t* The Android Developer Tools (ADT) Bundle. This includes Android SDK components and a version of the Eclipse IDE with built-in ADT.  \n\t\t>NOTE:  \n\t\t>Make sure to specify the extracted ADT Bundle folder as the ADT Root Folder (i.e. the parent folder which \"eclipse\" and \"sdk\" sub folders reside. See below).\n\t    >\n\t>![img](images/2.0/setup/image001.png)  \n\t* During installation, it will ask the approval for Motorola Android USB driver installation. If you have installed them already, skip this step.  \n\t* The existing Eclipse IDE and Android SDK (installed separately).  \n\t\t>NOTE:  \n\t\t>Make sure to specify the parent folder where \"eclipse.exe\" resides as the Eclipse Root Folder. See below.\n\t    >\n\t\t>![img](images/2.0/setup/image003.jpg)\n\t\t>\n\t\t>Make sure to specify the parent folder where \"platform-tools\" folder resides as the Android SDK Root Folder. See below.\n\t    >\n\t\t>![img](images/2.0/setup/image005.jpg)\n\n5.\tDuring installation, it will ask the approval for Motorola Android USB driver installation too. \n\t     \n\t![img](images/2.0/setup/image007.png)\n\n\t>NOTE:\n\t>\n\t>* If you have installed it already, click \"No\". Then it will switch back to the EMDK for Android installation.\n\t>\n\t>* If you have not installed, click \"Yes\". Then it will start the Motorola Android USB driver installation automatically. Once completed, make sure to select \"I want to manually reboot later\" and click \"Finish\". Then it will switch back to the EMDK for Android installation.\n\n## Configuring Device\n\n###\tInstalling EMDK for Android Device Runtime using Deployment utility\n\n1.\tConnect the Motorola Android device to the PC.\n2.\tLaunch the Start menu program shortcut \"Device Runtime Deployment\". This will open the command prompt window.\n3.\tClick any key to continue.\n4.\tThis process will deploy the device runtime and reboot automatically to finish the OS update.\n\n## Verifying EMDK for Android Development Environment\n\n###\tVerifying the EMDK Wizard plug-in integration into the ADT/Eclipse IDE  \n1.\tRun \"eclipse.exe\" available under \"<adt-bundle>\\eclipse\" (ex. \\adt-bundle-windows-x86-20140321\\eclipse\\eclipse.exe) or \"<eclipse-root>\" (ex. \\eclipse-standard-kepler-SR2-win32\\eclipse\\eclipse.exe).\n2.\tThe menu bar should contain a new menu called \"EMDK\" (see below)\n\n\t![img](images/2.0/setup/image009.jpg)\n\n### Verifying the SDK add-on integration into the ADT/Eclipse IDE\n1.\tSelect any existing Android application project.\n2.\tGo to \"File\" -> \"Properties\"\n\n\t![img](images/2.0/setup/image011.jpg)\n3.\tSelect \"Android\" from left pane.\n\n\t![img](images/2.0/setup/image001/image015.jpg)\n4.\tCheck the availability of \"Motorola Solutions EMDK v2.0\" in the list of Project Build Targets.\n\n\t![img](images/2.0/setup/image017.jpg)\n\n### Verifying EMDK for Android Runtime Environment\n\nTo check whether the EMDK runtime is installed on the device or not, check for the existence of \"/system/framework/com.symbol.emdk.jar\" on the device.\n\n\n![img](images/2.0/setup/image097.jpg)\n\n"},{"key":"guide-tutorial-tutbatteryintent","name":" Battery Intent - Tutorial","md":"# Battery Intent - Tutorial\n\n## Overview\nOn Motorola Solutions Android devices like the MC40, extra battery information can be retrieved using the standard [Android Battery Intent](http://developer.android.com/training/monitoring-device-state/battery-monitoring.html). Setting up to receive this information is the same as with consumer Android devices. However, the data that is returned to your application includes some extra information like:\n\n* Backup Battery Voltage\n* Battery Manufacture Date\n* Battery Serial Number\n* Part Number for Battery\n* Unique ID for Battery\n* Rated Capacity of the Battery\n* Charge Cycle count of the Battery \n\n## Enabling the Receiver \n\n\t:::java\n\tmIntent_Receiver = new Intent_Receiver();  \n\tmIntentFilter = new IntentFilter();  \n\tmIntentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);  \n\tregisterReceiver(mIntent_Receiver,mIntentFilter);  \n\n## Processing The Data\nIn the below code we are getting the Motorola Solutions specific battery information provided by the [Battery Intent](#guide-reference-refbatteryintent) extras. Notice that some values are strings and other values are integers.\n\n\t:::java\n\tpublic void onReceive(Context context, Intent intent) {      \n\t\tif (BATTERY_STATE_CHANGED_INTENT.equals(intent.getAction())) {          \n\t\t\tint bkvoltage = intent.getExtras().getInt(\"bkvoltage\");  \n\t\t\tString mfd = intent.getExtras().getString(\"mfd\");  \n\t\t\tString serialnumber = intent.getExtras().getString(\"serialnumber\");  \n\t\t\tString partnumber = intent.getExtras().getString(\"partnumber\");  \n\t\t\tString uniqueid = intent.getExtras().getString(\"uniqueid\");  \n\t\t\tint ratedcapacity = intent.getExtras().getInt(\"ratedcapacity\");  \n\t\t\tint cycle = intent.getExtras().getInt(\"cycle\");  \n\t\t}  \n\t} \n\n## Downloading the Sample\nDownload the source for this project in the [associated sample](#guide-sample-samplebatteryintent)."},{"key":"guide-tutorial-tutdatacaptureintent","name":" Data Capture - Intents Tutorial","md":"# Data Capture - Intents Tutorial\n\n## Overview\nDataWedge on Android has the ability to output captured data via Intents. This article describes how to use the DataWedge Intent output plug-in and the Data Capture API to receive captured data in your native Android application.\n\nKnowledge of Android programming and familiarity with the Android intent mechanism are assumed. Also assumed is some familiarity with DataWedge and that you have read the DataWedge section in the Integrator Guide for your device.\n \n## Application Layout\nFor this article we created an Android application with a blank activity using Eclipse, to which we added the following layout.\n\n    :::xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>  \n    <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n        android:layout_width=\"fill_parent\"  \n        android:layout_height=\"fill_parent\"  \n        android:orientation=\"vertical\" >  \n        <LinearLayout  \n            android:layout_width=\"fill_parent\"  \n            android:layout_height=\"wrap_content\"  \n            android:orientation=\"horizontal\" >  \n            <ImageView  \n                android:id=\"@+id/logo\"  \n                style=\"@style/logo\"  \n                android:contentDescription=\"@string/title\" />  \n            <LinearLayout  \n                android:layout_width=\"fill_parent\"  \n                android:layout_height=\"wrap_content\"  \n                android:orientation=\"vertical\" >  \n                <TextView style=\"@style/title\" />  \n                <TextView style=\"@style/copyright\" />  \n            </LinearLayout>  \n        </LinearLayout>  \n        <View style=\"@style/hr\" />  \n        <TextView style=\"@style/intro\" />  \n        <EditText  \n            android:id=\"@+id/editbox\"  \n            style=\"@style/editbox\"  \n            android:inputType=\"textMultiLine\"  \n            />  \n    </LinearLayout> \n\nThe things to note in the above layout are the ImageView and the EditText widgets.  The ImageView widget will effectively act as a button which can be used to toggle the scanner instead of pressing the trigger button on the device. The EditText widget will be used to display the data that we receive in the intent.\n \n## Intent Strings\nThe intent we will receive from DataWedge will contain a bundle of data which we will be retrieving using the Intent.getStringtExtra() and Intent.getSerializableExtra() methods.  \n\n### Data Items\nThe following is a list of the data item names that the bundle could contain.\n\n* String SOURCE_TAG = \"com.motorolasolutions.emdk.datawedge.source\";\n* String contains the source of the data i.e. scanner or MSR\n* String DATA_STRING_TAG = \"com.motorolasolutions.emdk.datawedge.data_string\";\n    * String contains the output data as a String. In the case of concatenated bar codes, the decode data is concatenated and sent out as a single string. In the case of MSR output, the data from the MSR tracks is concatenated and sent out as a single string.\n* String LABEL_TYPE_TAG = \"com.motorolasolutions.emdk.datawedge.label_type\";\n* String contains the label type of the bar code.\n* String DECODE_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.decode_data\";\n    * Decode data returned as a list of byte arrays. In most cases there will be one byte array per decode. For bar-code symbologies that support concatenation e.g. Codabar, Code128, MicroPDF, etc., the decoded data is stored in multiple byte arrays (one byte array per bar code). Clients can get data in each byte array by passing an index.\n\n### MSR Intent Names\nLet’s list the MSR intent names (in case we want to use these in the future).\nThe MSR related data added to the intent’s bundle can be retrieved using the Intent.getStringtExtra() and Intent.getSerializableExtra() calls, using the following String tags…\n\n* String MSR_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.msr_data\";\n    * The data from the MSR tracks is concatenated and sent out as a byte array.\n* String MSR_TRACK1_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1\";\n    * MSR track 1 data is returned as a byte array.\n* String MSR_TRACK2_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2\";\n    * MSR track 2 data is returned as a byte array.\n* String MSR_TRACK3_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3\";\n    * MSR track 3 data is returned as a byte array.\n* String MSR_TRACK1_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_status\";\n    * MSR track 1 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK2_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_status\";\n    * MSR track 2 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK3_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_status\";\n    * MSR track 3 decode status as an Integer where 0 indicates a successful decode.\n* String MSR_TRACK1_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_encrypted\";\n    * MSR track 1 encrypted data is returned as a byte array.\n* String MSR_TRACK2_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_encrypted\";\n    * MSR track 2 encrypted data is returned as a byte array.\n* String MSR_TRACK3_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_encrypted\";\n    * MSR track 3 encrypted data is returned as a byte array.\n* String MSR_TRACK1_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_hashed\";\n    * MSR track 1 hashed data is returned as a byte array.\n* String MSR_TRACK2_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_hashed\";\n    * MSR track 2 hashed data is returned as a byte array.\n* String MSR_TRACK3_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_hashed\";\n    * MSR track 3 hashed data is returned as a byte array.\n\n### Soft Scan Trigger Intent Names\nHere are the API intent names for the soft scan trigger…\n\n* String ACTION_SOFTSCANTRIGGER = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";\n    * This is the intent action for the soft scan trigger.\n* String EXTRA_PARAM = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";\n    * Parameter passed in the intent to specify the action the soft scan trigger should perform.  The following actions are recognized…\n* String DWAPI_START_SCANNING = \"START_SCANNING\";\n    * Start scanning.\n* String DWAPI_STOP_SCANNING = \"STOP_SCANNING\";\n    * Stop scanning.\n* String DWAPI_TOGGLE_SCANNING = \"TOGGLE_SCANNING\";\n    * Toggle scanning.\n\n>In the code that follows we will just be using the SOURCE_TAG, DATA_STRING_TAG and LABEL_TYPE_TAG intent data to display the intent data in the EditText widget.\n \n## Handling Intents\nIncoming intents can be handled by overriding the onNewIntent method.\n\n    :::java\n    @Override  \n    public void onNewIntent(Intent i) {  \n        handleDecodeData(i);  \n    }  \n\nOur *handleDecodeData()* method will responsible for getting the data from the intent, formatting it and adding it to the end of the edit box; something like this:\n\n    :::java\n    private void handleDecodeData(Intent i) {  \n        // check the intent action is for us  \n        if ( i.getAction().contentEquals(com.motorolasolutions.emdk.sample.dwdemosample.RECVR) ) {       \n            // define a string that will hold our output  \n      \n      \n            String out = \"\";  \n            // get the source of the data  \n            String source = i.getStringExtra(SOURCE_TAG);  \n            // save it to use later  \n            if (source == null) source = \"scanner\";  \n            // get the data from the intent  \n            String data = i.getStringExtra(DATA_STRING_TAG);  \n            // let's define a variable for the data length  \n            Integer data_len = 0;  \n            // and set it to the length of the data  \n            if (data != null) data_len = data.length();  \n            // check if the data has come from the barcode scanner  \n            if (source.equalsIgnoreCase(\"scanner\")) {  \n                // check if there is anything in the data  \n                if (data != null && data.length() > 0) {  \n                  // we have some data, so let's get it's symbology  \n                    String sLabelType = i.getStringExtra(LABEL_TYPE_TAG);  \n                    // check if the string is empty  \n                    if (sLabelType != null && sLabelType.length() > 0) {  \n                        // format of the label type string is LABEL-TYPE-SYMBOLOGY  \n                        // so let's skip the LABEL-TYPE- portion to get just the symbology  \n                        sLabelType = sLabelType.substring(11);  \n                    }  \n                    else {  \n                      // the string was empty so let's set it to \"Unknown\"  \n                        sLabelType = \"Unknown\";  \n                    }  \n                  // let's construct the beginning of our output string  \n                    out = \"Source: Scanner, \" + \"Symbology: \" + sLabelType + \", Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                }  \n            }  \n            // check if the data has come from the MSR  \n            if (source.equalsIgnoreCase(\"msr\")) {  \n                // construct the beginning of our output string  \n              out = \"Source: MSR, Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n            }  \n      \n      \n            // let's get our edit box view  \n            EditText et = (EditText)findViewById(R.id.editbox);  \n            // and get it's text into an editable string  \n            Editable txt = et.getText();  \n            // now because we want format our output  \n          // we need to put the edit box text into a spannable string builder  \n            SpannableStringBuilder stringbuilder = new SpannableStringBuilder(txt);  \n            // add the output string we constructed earlier  \n            stringbuilder.append(out);  \n            // now let's highlight our output string in bold type  \n          stringbuilder.setSpan(new StyleSpan(Typeface.BOLD), txt.length(), stringbuilder.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);  \n      \n      \n          // then add the barcode or msr data, plus a new line, and add it to the string builder  \n          stringbuilder.append(data + \"\\r\\n\");  \n          // now let's update the text in the edit box  \n          et.setText(stringbuilder);  \n            // we want the text cursor to be at the end of the edit box  \n            // so let's get the edit box text again  \n            txt = et.getText();  \n            // and set the cursor position at the end of the text  \n            et.setSelection(txt.length());  \n            // and we are done!  \n      }  \n    } \n\n\n## Toggling The Scan Trigger\nOur activity layout has an ImageView which we will use as a button to toggle the scan trigger.  This is done by using the Data Capture API.  The following code toggles the scan trigger each time the image is tapped.\n\n    :::java\n    ImageView img = (ImageView) findViewById(R.id.dwdemo_logo);  \n    img.setOnClickListener(new OnClickListener() {  \n        @Override  \n        public void onClick(View v) {  \n            Intent i = new Intent();  \n            i.setAction(ACTION_SOFTSCANTRIGGER);  \n            i.putExtra(EXTRA_PARAM, DWAPI_TOGGLE_SCANNING);  \n            DWDemoActivity.this.sendBroadcast(i);  \n            Toast.makeText(v.getContext(), \"Soft scan trigger toggled.\", Toast.LENGTH_SHORT).show();  \n        }  \n    }); \n\n\n## Putting It All Together\nLet’s put all that code together so that we can see what our final activity class should look like.\n\n    :::java\n    package com.motorolasolutions.emdk.sample.dwdemosample;  \n    import android.os.Bundle;  \n    import android.app.Activity;  \n    import android.content.Intent;  \n    import android.graphics.Typeface;  \n    import android.view.View;  \n    import android.view.View.OnClickListener;  \n    import android.widget.EditText;  \n    import android.widget.ImageView;  \n    import android.widget.Toast;  \n    import android.text.Editable;  \n    import android.text.SpannableString;  \n    import android.text.SpannableStringBuilder;  \n    import android.text.style.StyleSpan;  \n    public class MainActivity extends Activity {  \n        // Tag used for logging errors  \n        private static final String TAG = MainActivity.class.getSimpleName();  \n        // Let's define some intent strings  \n        // This intent string contains the source of the data as a string  \n        private static final String SOURCE_TAG = \"com.motorolasolutions.emdk.datawedge.source\";  \n        // This intent string contains the barcode symbology as a string  \n        private static final String LABEL_TYPE_TAG = \"com.motorolasolutions.emdk.datawedge.label_type\";  \n        // This intent string contains the barcode data as a byte array list  \n        private static final String DECODE_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.decode_data\";  \n        // This intent string contains the captured data as a string  \n        // (in the case of MSR this data string contains a concatenation of the track data)  \n        private static final String DATA_STRING_TAG = \"com.motorolasolutions.emdk.datawedge.data_string\";  \n        // Let's define the MSR intent strings (in case we want to use these in the future)  \n        private static final String MSR_DATA_TAG = \"com.motorolasolutions.emdk.datawedge.msr_data\";  \n        private static final String MSR_TRACK1_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1\";  \n        private static final String MSR_TRACK2_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2\";  \n        private static final String MSR_TRACK3_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3\";  \n        private static final String MSR_TRACK1_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_status\";  \n        private static final String MSR_TRACK2_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_status\";  \n        private static final String MSR_TRACK3_STATUS_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_status\";  \n        private static final String MSR_TRACK1_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_encrypted\";  \n        private static final String MSR_TRACK2_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_encrypted\";  \n        private static final String MSR_TRACK3_ENCRYPTED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_encrypted\";  \n        private static final String MSR_TRACK1_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track1_hashed\";  \n        private static final String MSR_TRACK2_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track2_hashed\";  \n        private static final String MSR_TRACK3_HASHED_TAG = \"com.motorolasolutions.emdk.datawedge.msr_track3_hashed\";  \n        // Let's define the API intent strings for the soft scan trigger    private static final String ACTION_SOFTSCANTRIGGER = \"com.motorolasolutions.emdk.datawedge.api.ACTION_SOFTSCANTRIGGER\";  \n        private static final String EXTRA_PARAM = \"com.motorolasolutions.emdk.datawedge.api.EXTRA_PARAMETER\";  \n        private static final String DWAPI_START_SCANNING = \"START_SCANNING\";  \n        private static final String DWAPI_STOP_SCANNING = \"STOP_SCANNING\";  \n        private static final String DWAPI_TOGGLE_SCANNING = \"TOGGLE_SCANNING\";  \n        private static String ourIntentAction = \"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\";  \n      \n      \n        @Override  \n        public void onCreate(Bundle savedInstanceState) {  \n            super.onCreate(savedInstanceState);  \n            setContentView(R.layout.activity_main);  \n            // Let's set the cursor at the end of any text in the editable text field        EditText et = (EditText)findViewById(R.id.editbox);  \n            Editable txt = et.getText();  \n            et.setSelection(txt.length());  \n      \n      \n            // Since we will be using the image as a soft scan trigger toggle button        // let's handle the image on onClick event  \n            ImageView img = (ImageView) findViewById(R.id.logo);  \n            img.setOnClickListener(new OnClickListener() {  \n                @Override  \n                public void onClick(View v) {  \n                    // the image has been tapped so shoot off the intent to DataWedge                // to toggle the soft scan trigger  \n                    // Create a new intent  \n                    Intent i = new Intent();  \n                    // set the intent action using soft scan trigger action string declared earlier  \n                    i.setAction(ACTION_SOFTSCANTRIGGER);  \n                    // add a string parameter to tell DW that we want to toggle the soft scan trigger  \n                    i.putExtra(EXTRA_PARAM, DWAPI_TOGGLE_SCANNING);  \n                    // now broadcast the intent  \n                    MainActivity.this.sendBroadcast(i);  \n                    // provide some feedback to the user that we did something                Toast.makeText(v.getContext(), \"Soft scan trigger toggled.\", Toast.LENGTH_SHORT).show();  \n                }  \n            });  \n      \n      \n            // in case we have been launched by the DataWedge intent plug-in  \n            // using the StartActivity method let's handle the intent  \n            Intent i = getIntent();  \n            handleDecodeData(i);  \n        }  \n      \n      \n        // We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n            handleDecodeData(i);  \n        }  \n      \n      \n        // This method is responsible for getting the data from the intent  \n        // formatting it and adding it to the end of the edit box  \n        private void handleDecodeData(Intent i) {  \n            // check the intent action is for us  \n            if ( i.getAction().contentEquals(ourIntentAction) ) {  \n                // define a string that will hold our output  \n                String out = \"\";  \n                // get the source of the data  \n                String source = i.getStringExtra(SOURCE_TAG);  \n                // save it to use later  \n                if (source == null) source = \"scanner\";  \n                // get the data from the intent  \n                String data = i.getStringExtra(DATA_STRING_TAG);  \n                // let's define a variable for the data length  \n      \n      \n                Integer data_len = 0;  \n                // and set it to the length of the data  \n                if (data != null) data_len = data.length();  \n                // check if the data has come from the barcode scanner  \n                if (source.equalsIgnoreCase(\"scanner\")) {  \n                    // check if there is anything in the data  \n                    if (data != null && data.length() > 0) {  \n                        // we have some data, so let's get it's symbology  \n                        String sLabelType = i.getStringExtra(LABEL_TYPE_TAG);  \n                        // check if the string is empty  \n                        if (sLabelType != null && sLabelType.length() > 0) {                        // format of the label type string is LABEL-TYPE-SYMBOLOGY  \n                            // so let's skip the LABEL-TYPE- portion to get just the symbology  \n                            sLabelType = sLabelType.substring(11);  \n                        }  \n                        else {  \n                            // the string was empty so let's set it to \"Unknown\"  \n                            sLabelType = \"Unknown\";  \n                        }  \n      \n      \n                        // let's construct the beginning of our output string  \n                        out = \"Source: Scanner, \" + \"Symbology: \" + sLabelType + \", Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                    }  \n                }  \n                // check if the data has come from the MSR  \n                if (source.equalsIgnoreCase(\"msr\")) {  \n                    // construct the beginning of our output string  \n                    out = \"Source: MSR, Length: \" + data_len.toString() + \", Data: ...\\r\\n\";  \n                }  \n      \n      \n                // let's get our edit box view  \n                EditText et = (EditText)findViewById(R.id.editbox);  \n                // and get it's text into an editable string  \n                Editable txt = et.getText();  \n                // now because we want format our output  \n      \n      \n                // we need to put the edit box text into a spannable string builder  \n                SpannableStringBuilder stringbuilder = new SpannableStringBuilder(txt);  \n                // add the output string we constructed earlier  \n                stringbuilder.append(out);  \n                // now let's highlight our output string in bold type  \n                stringbuilder.setSpan(new StyleSpan(Typeface.BOLD), txt.length(), stringbuilder.length(), SpannableString.SPAN_EXCLUSIVE_EXCLUSIVE);  \n                // then add the barcode or msr data, plus a new line, and add it to the string builder  \n                stringbuilder.append(data + \"\\r\\n\");  \n                // now let's update the text in the edit box  \n                et.setText(stringbuilder);  \n                // we want the text cursor to be at the end of the edit box  \n                // so let's get the edit box text again  \n                txt = et.getText();  \n                // and set the cursor position at the end of the text  \n                et.setSelection(txt.length());  \n                // and we are done!  \n            }  \n        }  \n    }  \n\n## Defining Intent Filters\nHaving dealt with the coding of our activity, we now need to inform the system which implicit intents our application can handle.  For that we need to define an intent-filter as follows.\n\n    :::xml\n    <intent-filter>  \n        <action android:name=\"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\"/>  \n        <category android:name=\"android.intent.category.DEFAULT\"/>  \n    </intent-filter>  \n\n\nWe will be using the com.motorolasolutions.emdk.sample.dwdemosample.RECVR action and the android.intent.category.DEFAULT category we have just defined above later on when we come to configure our DataWedge profile.\n\nIn this article DataWedge is configured to use the startActivity() method to send the intent. The startActivity() method causes a new activity to be launched. However since we do not want another instance of our activity launched each time we receive an intent, we need to specify the launch mode of our activity as single task.\nandroid:launchMode=\"singleTask\"\n\nAfter adding the above, our AndroidManifest.xml should look something like this…\n\n    :::xml\n    <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n        package=\"com.motorolasolutions.emdk.sample.dwdemosample\"  \n        android:versionCode=\"1\"  \n        android:versionName=\"1.0.0\" >  \n        <uses-sdk  \n            android:minSdkVersion=\"10\"  \n            android:targetSdkVersion=\"10\" />  \n        <application  \n            android:icon=\"@drawable/ic_launcher\"  \n            android:label=\"@string/app_name\"  \n            android:theme=\"@style/AppTheme\" >  \n            <activity  \n                android:name=\".MainActivity\"  \n                android:label=\"@string/app_name\"  \n                android:launchMode=\"singleTask\" >  \n                <intent-filter>  \n                    <action android:name=\"android.intent.action.MAIN\" />  \n                    <category android:name=\"android.intent.category.LAUNCHER\" />  \n                </intent-filter>  \n                <intent-filter>  \n                    <action android:name=\"com.motorolasolutions.emdk.sample.dwdemosample.RECVR\"/>  \n                    <category android:name=\"android.intent.category.DEFAULT\"/>  \n                </intent-filter>  \n                </activity>  \n        </application>  \n    </manifest>  \n\n## Configuring DataWedge\nNow we need to configure DataWedge to send the desired intent to our application.\n\nThe following steps will help you get started…\n\n* Launch DataWedge\n* Create a new profile and give it a name such as \"dwdemosample\"\n* Edit the profile\n* Go into Associated apps, tap the menu button, and add a new app/activity\n* For the application select com.motorolasolutions.emdk.sample.dwdemosample\n* For the activity select com.motorolasolutions.emdk.sample.dwdemosample.MainActivty\n* Go back and disable the keystroke output plug-in\n* Enable the intent output plug-in\n* For the intent action enter com.motorolasolutions.emdk.sample.dwdemosample.RECVR\n* For the intent category enter android.intent.category.DEFAULT\n \n## Summary\nThat’s it.  You should now be able to scan a bar-code and see it appear in the sample application.\nIn this article, we covered:\n\n* DataWedge intent strings\n* Handling intents from Data Capture\n* Receiving barcode/MSR data\n* Sending intents to Data Capture\n* Toggling of the soft scan trigger\n* Defining intent filters\n* Configuring DataWedge to send intents to our application\n\n## Sample Code\nDownload the source for this project in the [associated sample](#guide-sample-sampledatacaptureintent)."},{"key":"guide-tutorial-tutdatacaptureprofile","name":" Data Capture - Profile Manager Tutorial","md":"# Data Capture - Profile Manager Tutorial\n## Developing an EMDK for Android Application Part 1\n\nThis guide will walk you through creating an EMDK For Android application that will use [Data Capture Profiles](#guide-profiles-profilebarcode) to get barcode data into your application using the [KeyStroke output](#guide-profiles-profilekeystroke) feature of [EMDK Profiles](#guide-profiles-usingwizard). \n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT)\n* Motorola EMDK for Android \n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n1.  Create new Android Application project.  \n    ![img](images/2.0/setup/image019.jpg)\n2.  Assign names for the application and package. \n3.  Set the minimum required SDK to \"API 16: Android 4.1 (Jelly Bean)\".  \n    ![img](images/2.0/setup/image021.jpg)\n4.  Click \"Next\".  \n    ![img](images/2.0/setup/image023.jpg)  \n5.  Click \"Next\".  \n    ![img](images/2.0/setup/image025.jpg)  \n6.  Click \"Next\".  \n7.  Select \"Empty Activity\" Click \"Next\".  \n\n    ![img](images/2.0/setup/image100.jpg)  \n\n    >Note:  \n    >If \"Empty Activity\" is not available make sure you are using \"Android SDK Tools 22.6.3\" and \"Android SDK Platform Tools 19.0.2\"\n\n7.  Click \"Next\".  \n\n    ![img](images/2.0/setup/image102.jpg)  \n8.  Click \"Finish\".\n\n    >Note:  \n    >Currently there is nothing under \"\\assets\" folder.  \n    \n    ![img](images/2.0/setup/image031.jpg)  \n\n## Enabling the EMDK\n9.  Select the project.  \n10. Select \"File -> Properties\" or right click on the project and select \"Properties\".  \n    ![img](images/2.0/setup/image033.jpg)   \n    ![img](images/2.0/setup/image035.jpg)   \n11.    Click \"Android\" from the left pane.  \n    ![img](images/2.0/setup/image037.jpg) \n12. Select \"Motorola Solutions EMDK v2.0\" from the list of Project Build Targets.  \n    ![img](images/2.0/setup/image039.jpg)  \n\n    >Note:  \n    >If \"Motorola Solutions EMDK v2.0\" is not on the list of Build Tagets, please confirm you have installed Android API 16 SDK Platform.\n\n13. Click \"Apply\" and \"OK\".  \n    >Note:  \n    >The EMDK library will be added to the project.  \n    \n    ![img](images/2.0/setup/image041.jpg) \n\n    >Note:\n    >If you are using Java 1.7 as the compiler, you may see this error\n    \n    ![img](images/2.0/setup/image098.jpg) \n\n    > To correct this, you will need to change the compiler to use 1.6\n    \n    > * Click on the Java Compiler\n    > * Click Enable project specific settings\n    > * Select 1.6 for Compiler compliance level\n    \n    ![img](images/2.0/setup/image101.jpg) \n\n## Adding a DataCapture Profile\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu and select \"Profile Manager\".  \n    ![img](images/2.0/setup/image043.jpg)  \n3. The EMDK Profile Manager Window will appear.  \n    ![img](images/2.0/setup/image045.jpg)  \n4. Click \"Create\" and assign a name for the profile (Ex: DataCaptureProfile).  \n    ![img](images/2.0/setup/image047.jpg)  \n5. Click \"Create\". The Profile Editor window will appear.  \n    ![img](images/2.0/setup/image049.jpg)  \n6. Select any feature from the list and click \"Right Arrow\" (Ex: \"ActivitySelection\" has been selected. By using this feature Activities can be associated with the application. Then the data capture feature will be enabled automatically when the specified activity is in foreground).  \n    ![img](images/2.0/setup/image051.jpg)  \n7. Click on the selected feature. The parameter list will be populated.  \n    ![img](images/2.0/setup/image053.jpg)  \n8. Click \"ActivitySelection\" under parameters.  \n    ![img](images/2.0/setup/image055.jpg)  \n9. Specify the applications package name and click \"Apply\".  \n    ![img](images/2.0/setup/image057.jpg)  \n10. Specify an Activity inside the application and click \"Apply\".  \n    ![img](images/2.0/setup/image059.jpg)  \n11. Click \"OK\".  \n    ![img](images/2.0/setup/image061.jpg)  \n12. Select any data capture feature and click Right Arrow (Ex: \"Barcode\" has been selected).  \n    ![img](images/2.0/setup/image063.jpg)  \n13. Click on the \"Barcode\" feature. The parameter list will be populated.  \n    ![img](images/2.0/setup/image065.jpg)  \n14.    Enable the feature and change some parameters.  \n    ![img](images/2.0/setup/image067.jpg)  \n    ![img](images/2.0/setup/image069.jpg)  \n    ![img](images/2.0/setup/image071.jpg)  \n15.    Click \"Apply\". \n16.    Select the Keystroke feature and click \"Right Arrow\" (Ex: \"Keystroke\" has been selected).  \n    ![img](images/2.0/setup/image073.jpg)  \n17. Enable the feature and change some parameters.  \n    ![img](images/2.0/setup/image075.jpg)  \n    ![img](images/2.0/setup/image077.jpg)  \n18. Click \"Apply\" and \"Finish\".  \n    ![img](images/2.0/setup/image079.jpg)  \n19.    Click \"Close\".  \n\n    >Note:  \n    >Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n    ![img](images/2.0/setup/image081.jpg)  \n20. You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n    ![img](images/2.0/setup/image083.jpg)   \n    ![img](images/2.0/setup/image085.jpg)   \n\n## Enabling Android Permissions\n1. Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK.  \n    ![img](images/2.0/setup/image087.jpg)\n\n    You must first enable permissions for 'com.symbol.emdk.permission.EMDK':  \n   \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/> \n\n    Then you must enable the library:  \n      \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\" />\n\n    When done, your manifest.xml should look like:\n\n    ![img](images/2.0/setup/image089.jpg)  \n\n##Adding Some Code    \n1. Now we will start to add some code. \n\n    First you must add references to the libraries:  \n    \n        :::java\n        import com.symbol.emdk.*;  \n        import com.symbol.emdk.EMDKManager.EMDKListener;  \n    \n    Then you must extend the activity to implement EMDKListener. Use Eclipse’s Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n        :::java\n        public class MainActivity extends Activity implements EMDKListener {  \n          \n            .. .. .. .. .. .. ...  \n          \n            @Override  \n            public void onClosed() {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n            @Override  \n            public void onOpened(EMDKManager emdkManager) {  \n                   // TODO Auto-generated method stub  \n            }  \n          \n        }      \n\n    We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager that we will use throughout the code:  \n    \n        :::java\n        //Assign the profile name used in EMDKConfig.xml  \n        private String profileName = \"DataCaptureProfile\";  \n          \n        //Declare a variable to store ProfileManager object  \n        private ProfileManager mProfileManager = null;  \n          \n        //Declare a variable to store EMDKManager object  \n        private EMDKManager emdkManager = null;     \n\n    In the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n        :::java\n        //The EMDKManager object will be created and returned in the callback.  \n        EMDKResults results = EMDKManager.getEMDKManager(getApplicationContext(), this);  \n          \n        //Check the return status of getEMDKManager  \n        if(results.statusCode == STATUS_CODE.FAILURE)  \n        {  \n                //Failed to create EMDKManager object  \n                \n        }  \n\n    So far your code should look like:\n     \n     ![img](images/2.0/setup/image091.jpg) \n\n2. Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `mProfileManager`. This is how we will interface with the APIs in the rest of the code:  \n\n        :::java\n        this.emdkManager = emdkManager;  \n        //Get the ProfileManager object to process the profiles  \n        mProfileManager = (ProfileManager) emdkManager.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);         \n    \n    Now that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:  \n\n        :::java\n        if(mProfileManager != null)  \n        {  \n            String[] modifyData = new String[1];  \n            //Call processPrfoile with profile name and SET flag to create the profile. The modifyData can be null.  \n         \n            EMDKResults results = mProfileManager.processProfile(profileName, ProfileManager.PROFILEFLAG.SET, modifyData);  \n             if(results.statusCode == STATUSCODE.FAILURE)  \n             {  \n                 //Failed to set profile  \n             }  \n        }  \n\n    Your onOpened method should now look like this:\n    \n    ![img](images/2.0/setup/image095.jpg)  \n    \n3. Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:  \n\n        :::java\n        @Override  \n        protected void onDestroy() {  \n            // TODO Auto-generated method stub  \n            super.onDestroy();  \n            //Clean up the objects created by EMDK manager  \n            emdkManager.release();  \n        } \n\n    Your onDestroy method should now look like this:  \n\n    ![img](images/2.0/setup/image093.jpg)  \n\n4. Remove the default \"TextView\", inside \"res/layout/activity_main.xml\".\n\n5. Add an EditText Field in the UI called \"editTextBarcode\", inside \"res/layout/activity_main.xml\".\n    \n        :::xml\n        <EditText  \n            android:id=\"@+id/editTextBarcode\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_marginTop=\"200dp\"  \n            android:layout_marginLeft=\"50dp\"  \n            android:ems=\"10\" >  \n\n6. Connect Motorola Solutions Android device (having the latest EMDK runtime) to the USB port.\n    >Note:   \n    >Make sure the device is in USB debug.\n7. Run the application.  \n\t![img](images/2.0/setup/image103.png)  \n8. Press the trigger button and scan a barcode.\n9. The scanned data will be populated in the Edit Text field added to the UI.  \n\t![img](images/2.0/setup/image104.png)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n    >Note:\n    >* Include the permission for EMDK:  \n    \n        :::xml\n        <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n    \n    >* Use the EMDK library:  \n    \n        :::xml\n        <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. When using the \"Barcode\" feature in EMDK Wizard, the specified value for \"Scanner\" is not supported on the device, it will be considered as \"Auto\" during runtime (Ex: BT_LASER1, BT_IMAGER1 and BT_CAMERA1).\n3. Installing the EMDK for Android application without deploying the EMDK runtime on the Motorola Solutions Android  device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n## What's Next\nNow that you have learned the basics of an EMDK for Android application, the [next tutorial](#guide-tutorial-tutdatacaptureprofilePt2)</a> will show you how to use the [Intent Output](#guide-profiles-profileintent) feature of EMDK Profiles to handle Data Capture output programatically.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-DataCapture-ProfileManagerTutorial.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt2","name":" Data Capture Profiles- Using Intent Output","md":"# Data Capture Profiles- Using Intent Output\n## Developing an EMDK for Android Application Part 2\n\nThis tutorial will walk you through adding [Intent Output](#guide-profiles-profileintent) support to the EMDK For Android application you made using [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile). This tutorial will assume your project is at the state of the end of that tutorial and build on top of it. You can follow the tutorial in the previous step of download the source from the previous step and start from there.\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT)\n* Motorola EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Adding Intents to the DataCapture Profile\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu and select \"Profile Manager\".  \n    ![img](images/2.0/setup/image043.jpg)  \n3. The EMDK Profile Manager Window will appear.  \n    ![img](images/2.0/setup/image105.jpg)  \n4. select \"DataCaptureProfile\" and click \"Edit\".\n5. Select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\".\n\t![img](images/2.0/setup/image106.jpg)  \n6. Select \"Intent\" from the list of \"Selected Features\". \n7. Now we will configure the \"Intent\" settings.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVR\".\n\t* For \"Intent Output Category\" enter \"android.intent.category.DEFAULT\".\n\t* Switch \"Intent Output Delivery\" to \"Send via startActivity\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:  \n\t![img](images/2.0/setup/image107.jpg)  \n\n7. Click \"Apply\" and \"Finish\".  \n    ![img](images/2.0/setup/image079.jpg)  \n8. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" under \"\\assets\" folder will be updated with your changes.\n\n##Adding the Intent Filter\n1. Open your application's \"Manifest.xml\" file.  \n\t![img](images/2.0/setup/image087.jpg)\n2. Make the following changes to your application's\"Manifest.xml\" file.  \n\n\tAdd the following parameter to your activity settings to enable \"singleTask\" mode.\n\t\n        :::xml\n        android:launchMode=\"singleTask\"  \n\t\n\tAdd the following lines to receive EMDK Intents in your application: \n\n        :::xml\n        <intent-filter>  \n                <action android:name=\"com.symbol.emdksample.RECVR\"/>  \n                <category android:name=\"android.intent.category.DEFAULT\"/>  \n        </intent-filter>     \n\n    When done, your manifest.xml should look like this:\n\n    ![img](images/2.0/setup/image108.jpg)  \n\n\t>Note:  \n\t>\n\t>* The intent action name should match the value of \"Intent Output Action\" in the EMDK Profile Manager. \n\t>* The intent category name should match the value of \"Intent Output Category\" in the EMDK Profile Manager.\n\n##Adding the Intent code\n1. Add the following imports to your program.\n\n        :::java\n        import android.content.Intent;  \n        import android.widget.TextView; \n\n\t![img](images/2.0/setup/image109.jpg) \n2. Add the following function to your program for processing intents. \n\n        :::java\n        //This function is responsible for getting the data from the intent  \n        private void handleDecodeData(Intent i)  \n        {  \n          \n        }\n     \n    ![img](images/2.0/setup/image110.jpg) \n3. Add the following code to your \"onCreate\" function check for a possible intent; \n\n        :::java\n        //In case we have been launched by the DataWedge intent plug-in  \n        Intent i = getIntent();  \n        handleDecodeData(i); \n\n    ![img](images/2.0/setup/image112.jpg)  \n4. Overide \"onNewIntent\" to handle incoming intents. \n\n        :::java\n        //We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n                handleDecodeData(i);  \n           \n        } \n     \n    ![img](images/2.0/setup/image111.jpg)\n5. Add a TextView in the UI called \"textViewBarcode\", inside \"res/layout/activity_main.xml\".\n    \n        :::xml\n        <TextView  \n                android:id=\"@+id/textViewBarcode\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_alignParentTop=\"true\"  \n            android:layout_centerHorizontal=\"true\"  \n            android:layout_marginTop=\"50dp\"  \n            android:text=\"@+string/hello_world\"  \n            android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/2.0/setup/image113.jpg)  \n6. Add a global variable for the TextView. \n \n        :::java\n        //Declare a variable to store the textViewBarcode  \n        private TextView textViewBarcode = null;\n\t\n\t![img](images/2.0/setup/image114.jpg)    \n7. Add the following code to your onCreate function to get a handle on the TextView.\n \n        :::java\n        //Get the textViewBarcode  \n        textViewBarcode = (TextView) findViewById(R.id.textViewBarcode); \n\n\t![img](images/2.0/setup/image115.jpg)   \n8. Add the following code to your \"handleDecodeData\" function to confirm the intent was meant for us. \n\n        :::java\n        //Check the intent action is for us  \n        if (i.getAction().contentEquals(\"com.symbol.emdksample.RECVR\") ) {  \n          \n        } \n    \n    ![img](images/2.0/setup/image116.jpg)   \n    \n9. Add the following code to your \"handleDecodeData\" function to check if the intent contains Barcode data.  \n\n        :::java\n        //Get the source of the data  \n        String source = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n          \n        //Check if the data has come from the Barcode scanner  \n        if(source.equalsIgnoreCase(\"scanner\"))  \n        {  \n          \n        }\n\n\t![img](images/2.0/setup/image117.jpg)   \n10. Add the following code to your \"handleDecodeData\" function to retrieve Barcode data.  \n\n        :::java\n        //Get the data from the intent  \n        String data = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n          \n        //Check that we have received data  \n        if(data != null && data.length() > 0)  \n        {  \n          \n        } \n\n\t![img](images/2.0/setup/image118.jpg)\n\n11. Add the following code to your \"handleDecodeData\" function to populate the TextView with the revived Barcode data.\n\n        :::java\n        //Display the data to the text view  \n        textViewBarcode.setText(\"Data = \" + data); \n\n\t![img](images/2.0/setup/image119.jpg) \n12. Connect Motorola Solutions Android device (having the latest EMDK runtime) to the USB port.\n    \n    >Note:   \n    >Make sure the device is in USB debug.\n\n13. Run the application.  \n\t![img](images/2.0/setup/image120.png) \n14. Press the trigger button and scan a Barcode.\n15. The scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the Text View using the new Datawedge Intent.   \n\t![img](images/2.0/setup/image121.png) \n\n\n## What's Next\nThe [next tutorial](#guide-tutorial-tutdatacaptureprofilePt3) will show you how to use multiple Data Capture Profiles that are handled by multiple activities.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-DataCaptureProfiles-Using+Intent+Output.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt3","name":" Using Multiple Data Capture Profiles","md":"# Using Multiple Data Capture Profiles\n## Developing an EMDK for Android Application Part 3\n\nThis guide will walk you through adding MSR support and multiple profiles to the Android application you made using [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilept2). This tutorial will add some more complexity by adding a second screen as well as adding a second Data Capture Profile.\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT)\n* Motorola EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n* Completion of [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilePt2)\n \nFor more information about setting up the EMDK please see the EMDK [Setup](#guide-setup).\n\n##Adding MSR Activity\nLet's start by defining a second activity for the application. This activity will be used to to activate a Data Capture profile that listens for MSR data.\n\n1. Select \"EMDKSample\" from \"Package Explorer\" in Eclipse.  \n    ![img](images/2.0/setup/image122.jpg)  \n2. Right Click and select \"New\" -> \"Other\".  \n    ![img](images/2.0/setup/image123.jpg)  \n3. Select \"Android\" -> \"Android Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image124.jpg)  \n4. Select \"Empty Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image125.jpg)  \n5. Change \"Activity name\" to \"MSRActivity\" and click \"Finish\".  \n    ![img](images/2.0/setup/image126.jpg)  \n\n##Adding MSR Completed Activity\nNext let's create a third activity that will listen for the MSR data and display the data to the user.\n\n1. Select \"EMDKSample\" from \"Package Explorer\" in Eclipse.  \n    ![img](images/2.0/setup/image122.jpg)  \n2. Right Click and select \"New\" -> \"Other\".  \n    ![img](images/2.0/setup/image123.jpg)  \n3. Select \"Android\" -> \"Android Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image124.jpg)  \n4. Select \"Empty Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image125.jpg)  \n5. Change \"Activity name\" to \"MSRCompletedActivity\" and click \"Finish\".  \n    ![img](images/2.0/setup/image127.jpg)  \n\n##Updating Main Activity\nNow we will update \"MainActivity\", adding a button to launch our \"MSRActivity\".\n\n1. Select \"activity_main.xml\" from \"Package Explorer\" in Eclipse.  \n\t![img](images/2.0/setup/image128.jpg)  \n2. Add the following Button to \"activity_main.xml\". This Button will be used for opening \"MSRActivity\".  \n\t\n        :::xml\n        <Button  \n        android:id=\"@+id/buttonMSR\"  \n        android:layout_width=\"wrap_content\"  \n        android:layout_height=\"wrap_content\"  \n        android:layout_alignParentBottom=\"true\"  \n        android:layout_marginBottom=\"50dp\"  \n        android:layout_marginLeft=\"50dp\"  \n        android:text=\"MSR\" />\n\n\t![img](images/2.0/setup/image129.jpg)  \n3. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image130.jpg) \n4. Add the following Imports to \"MainActivity.java\".  \n\t\n        :::java\n        import android.widget.Button;  \n        import android.view.View;  \n        import android.view.View.OnClickListener; \n\n\t![img](images/2.0/setup/image131.jpg)  \n5. Declare a variable inside \"MainActivity\" to store \"buttonMSR\". \n\t\n        :::java\n        //Declare a variable to store the buttonMSR  \n        private Button buttonMSR = null;  \n\n\t![img](images/2.0/setup/image132.jpg)  \n6. Inside \"onCreate\" get a reference to \"buttonMSR\".\n\t\n        :::java\n        //Declare a variable to store the buttonMSR  \n        private Button buttonMSR = null; \n\n\t![img](images/2.0/setup/image133.jpg)  \n7. Inside \"onCreate\" add an \"OnClickListener\" for \"buttonMSR\".  \n\t\n        :::java\n        //Add an OnClickListener for buttonMSR  \n        buttonMSR.setOnClickListener(buttonMSROnClick);     \n\n\t![img](images/2.0/setup/image134.jpg)  \n\n8. Add a new \"OnClickListener\" inside \"MainActivity\". \n\n        :::java\n        //OnClickListener for buttonMSR  \n        private OnClickListener buttonMSROnClick = new OnClickListener() {  \n            public void onClick(View v) {  \n          \n            }  \n        };  \n\n\t![img](images/2.0/setup/image135.jpg)  \n9. Add the following code to \"onClick\" to launch \"MSRActivity\". \n\n        :::java\n        //Launch MSRActivity  \n        Intent myIntent = new Intent(MainActivity.this, MSRActivity.class);  \n        startActivity(myIntent);  \n\n\t![img](images/2.0/setup/image136.jpg) \n\n##Creating MSR UI\nNext we will create the UI for \"MSRActivity\". \n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse.  \n\t![img](images/2.0/setup/image137.jpg) \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n        :::xml\n        <TextView  \n            android:id=\"@+id/textViewInfo\"  \n            android:layout_width=\"wrap_content\"  \n            android:layout_height=\"wrap_content\"  \n            android:layout_alignParentTop=\"true\"  \n            android:layout_centerHorizontal=\"true\"  \n            android:layout_marginTop=\"50dp\"  \n            android:text=\"Please swipe a card to continue.\"  \n            android:textAppearance=\"?android:attr/textAppearanceLarge\" /> \n\n\t![img](images/2.0/setup/image138.jpg) \n\n##Creating our MSR Profile\nNext we will create a Data Capture profile that will activate the MSR on \"MSRActivity\" and send the data via a startActivity Intent to \"MSRCompletedActivity\".  \n\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu and select \"Profile Manager\".  \n    ![img](https://launchpad-images.s3-us-west-1.amazonaws.com/emdk/setup/image043.jpg)  \n3. The EMDK Profile Manager Window will appear.  \n    ![img](images/2.0/setup/image139.jpg)  \n4. click \"Create\".  \n    ![img](images/2.0/setup/image140.jpg)  \n5. Enter the Profile Name \"DataCaptureProfileMSR\" and click \"Create\".  \n    ![img](images/2.0/setup/image141.jpg)  \n6. select \"ActivitySelection\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.  \n    ![img](images/2.0/setup/image142.jpg)  \n7. Select \"Activity Selection\".  \n    ![img](images/2.0/setup/image143.jpg)  \n8. Enter \"com.symbol.emdksample\" as the application name and click apply.  \n    ![img](images/2.0/setup/image144.jpg)  \n9. Enter \"MSRActivity\" as the activity name and click apply.  \n    ![img](images/2.0/setup/image145.jpg)  \t\n10. Click Okay.  \n11. select \"MSR\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow. \n    ![img](images/2.0/setup/image146.jpg)  \t\n12. Change \"MSR Input Enable\" to \"Enable\".  \n\t![img](images/2.0/setup/image147.jpg) \n13. select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow. \n\t![img](images/2.0/setup/image148.jpg) \n14. Now we will configure the \"Intent\" settings.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVRMSR\".\n\t* For \"Intent Output Category\" enter \"android.intent.category.DEFAULT\".\n\t* Switch \"Intent Output Delivery\" to \"Send via startActivity\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:  \n\t![img](images/2.0/setup/image149.jpg)  \n\n15. Click \"Apply\" and \"Finish\".  \n    ![img](images/2.0/setup/image150.jpg)  \n16. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" file under the \"\\assets\" folder will be updated with your changes.\n\n##Adding the MSR Intent Filter\nNow will add an Intent filter to our Manifest file to allow \"MSRCompletedActivity\" to listen for our new Data Capture Intent. \n\n1. Open your application's \"Manifest.xml\" file.  \n\t![img](images/2.0/setup/image151.jpg)\n2. Add the following configuration to the activity \"com.symbol.emdksample.MSRCompletedActivity\" to revive our MSR intent.  \n\n        :::xml\t \n        <intent-filter>  \n                <action android:name=\"com.symbol.emdksample.RECVRMSR\"/>  \n                <category android:name=\"android.intent.category.DEFAULT\"/>  \n        </intent-filter>  \n\n    When done, your manifest.xml should look like this:\n\n    ![img](images/2.0/setup/image152.jpg)  \n\n\t>Note:  \n\t>\n\t>* The intent action name should match the value of \"Intent Output Action\" in the EMDK Profile Manager. \n\t>* The intent category name should match the value of \"Intent Output Category\" in the EMDK Profile Manager.\n\n##Registering the MSR EMDK profile\nNext we will register our new Data Capture profile from \"MainActivity\".\n\n1. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image153.jpg) \n2. Inside \"MainActivity\" add the following code to hold the name of our MSR profile.  \n\n        :::java\n        //Assign the profile name used in EMDKConfig.xml  for MSR handling  \n        private String profileNameMSR = \"DataCaptureProfileMSR\";  \n\n    ![img](images/2.0/setup/image154.jpg)  \n3. Inside \"onOpened\" add the following code to register the MSR EMDK profile. \n\n        :::java\n        //Call processPrfoile for profile MSR  \n        results = mProfileManager.processProfile(profileNameMSR, ProfileManager.PROFILE_FLAG.SET, modifyData);  \n          \n        if(results.statusCode == STATUS_CODE.FAILURE)  \n        {  \n        //Failed to set profile MSR  \n        }  \n\n    ![img](images/2.0/setup/image155.jpg)  \n\n##Creating MSR Completed UI\nNow we will create the UI for \"MSRCompletedActivity\". This UI will allow us to display the MSR data to the user.\n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse.  \n\t![img](images/2.0/setup/image156.jpg) \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n    :::xml\n    <TextView  \n        android:id=\"@+id/textViewMSRData\"  \n        android:layout_width=\"wrap_content\"  \n        android:layout_height=\"wrap_content\"  \n        android:layout_alignParentTop=\"true\"  \n        android:layout_centerHorizontal=\"true\"  \n        android:layout_marginTop=\"50dp\"  \n        android:text=\"Data = \"  \n        android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/2.0/setup/image157.jpg) \n\n##Handling MSR Intents\nNext will will add the code to \"MSRCompletedActivity\" for capturing the startActivity Intent and displaying the result data to the user. \n\n1. Select \"MSRCompletedActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image158.jpg) \n2. Add the following imports.  \n\n        :::java\n        import android.content.Intent;  \n        import android.widget.TextView; \n\n\t![img](images/2.0/setup/image159.jpg)  \n3. Add the following function for processing intents.  \n\n        :::java\n        //This function is responsible for getting the data from the intent  \n        private void handleDecodeData(Intent i)  \n        {  \n          \n        }  \n     \n    ![img](images/2.0/setup/image160.jpg)  \n4. Add the following code to your \"onCreate\" function to check for a possible intent;  \n\n        :::java\n        //In case we have been launched by the DataWedge intent plug-in  \n        Intent i = getIntent();  \n        handleDecodeData(i);\n     \n    ![img](images/2.0/setup/image161.jpg)  \n5. Overide \"onNewIntent\" to handle incoming intents.  \n\n        :::java\n        //We need to handle any incoming intents, so let override the onNewIntent method  \n        @Override  \n        public void onNewIntent(Intent i) {  \n            handleDecodeData(i);  \n           \n        }\n     \n    ![img](images/2.0/setup/image162.jpg)  \n6. Add a global variable for the TextView. \n\n        :::java\n        //Declare a variable to store the textViewMSRData  \n        private TextView textViewMSRData = null; \n\t\n\t![img](images/2.0/setup/image163.jpg)  \n7. Add the following code to your onCreate function to get a handle on the TextView.\n \n        :::java\n        //Get the textViewBarcode  \n        textViewMSRData = (TextView) findViewById(R.id.textViewMSRData); \n\n\t![img](images/2.0/setup/image164.jpg)   \n8. Add the following code to your \"handleDecodeData\" function to confirm the intent was meant for us. \n\n        :::java\n        //Check the intent action is for us  \n        if (i.getAction().contentEquals(\"com.symbol.emdksample.RECVRMSR\"))  \n        {  \n          \n        }\n    \n    ![img](images/2.0/setup/image165.jpg)   \n9. Add the following code to your \"handleDecodeData\" function to check if the intent contains MSR data.  \n\n        :::java\n        //Get the source of the data  \n        String source = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n          \n             \n        //Check if the data has come from the msr  \n        if(source.equalsIgnoreCase(\"msr\"))  \n        {  \n          \n        }  \n\n\t![img](images/2.0/setup/image166.jpg)  \n10. Add the following code to your \"handleDecodeData\" function to retrieve MSR data.  \n\n        :::java\n        //Get the data from the intent  \n        String data = i.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n          \n        //Check that we have received data  \n        if(data != null && data.length() > 0)  \n        {  \n          \n        }\n\n\t![img](images/2.0/setup/image167.jpg)\n11. Add the following code to your \"handleDecodeData\" function to populate the TextView with the revived MSR data.\n\n        :::java\n        //Display the data to textViewMSRData  \n        textViewMSRData.setText(\"Data = \" + data);  \n\n\t![img](images/2.0/setup/image168.jpg) \n\n##Running the Application\nLastly we will run and test our application. \n\n1. Connect Motorola Solutions Android device (having the latest EMDK runtime) to the USB port.\n\n    >Note:   \n    >Make sure the device is in USB debug.\n\n2. Run the application.  \n\n\t![img](images/2.0/setup/image169.png) \n3. Press the trigger button and scan a Barcode. \n4. Like before the scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the Text View using the previous Datawedge Intent.   \n\n\t![img](images/2.0/setup/image170.png) \n5. Press the button \"MSR\".  \n\n\t![img](images/2.0/setup/image171.png)\n6. Swipe a cad through the MSR.  \n\n\t![img](images/2.0/setup/image172.png)\n7. Press return to go back to the MSR where you can swipe another card, or hit return again to go back to the main screen. \n\n## What's Next\nThe [next tutorial](#guide-tutorial-tutdatacaptureprofilePt4) will show you how to use the Intent Output as a Broadcast instead of starting an activity.\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-UsingMultipleDataCaptureProfiles.zip)."},{"key":"guide-tutorial-tutdatacaptureprofilePt4","name":" Using Broadcast Intent in DataCapture Profiles","md":"# Using Broadcast Intent in DataCapture Profiles\n## Developing an EMDK for Android Application Part 4\n\nThis guide will walk you through adding broadcast intent support to the Android application you made using [Developing an EMDK for Android Application Part 3](#guide-tutorial-tutdatacaptureprofilept3).\n\n###Prerequisites\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT)\n* Motorola EMDK for Android \n* Completion of [Developing an EMDK for Android Application Part 1](#guide-tutorial-tutdatacaptureprofile)\n* Completion of [Developing an EMDK for Android Application Part 2](#guide-tutorial-tutdatacaptureprofilePt2)\n* Completion of [Developing an EMDK for Android Application Part 3](#guide-tutorial-tutdatacaptureprofilePt3)\n \nFor more information about setting up the EMDK please see the EMDK [Setup](#guide-setup).\n\n##Using EMDK Wizard and EMDK for Android Broadcast Intents.\n\n###Adding Broadcast Intent Activity\nFirst we will add a new activity that will be used for listening and displaying Barcode data to the user. \n\n1. Select \"EMDKSample\" from \"Package Explorer\" in Eclipse.  \n    ![img](images/2.0/setup/image122.jpg)  \n2. Right Click and select \"New\" -> \"Other\".  \n    ![img](images/2.0/setup/image123.jpg)  \n3. Select \"Android\" -> \"Android Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image124.jpg)  \n4. Select \"Empty Activity\" and click \"Next\".  \n    ![img](images/2.0/setup/image125.jpg)  \n5. Change \"Activity name\" to \"BroadcastIntentActivity\" and click \"Finish\".  \n    ![img](images/2.0/setup/image169.jpg)  \n\n###Updating Main Activity\nNext we will update \"MainActivity\", adding a button to launch our \"BroadcastIntentActivity\".\n\n1. Select \"activity_main.xml\" from \"Package Explorer\" in Eclipse.  \n\t![img](images/2.0/setup/image170.jpg)  \n2. Add the following Button to \"activity_main.xml\". This Button will be used for opening \"BroadcastIntentActivity\".  \n\n\t\t:::xml\n\t\t<Button  \n\t\t     \n\t\t    android:id=\"@+id/buttonBroadcastIntent\"  \n\t\t    android:layout_width=\"wrap_content\"  \n\t\t    android:layout_height=\"wrap_content\"  \n\t\t    android:layout_alignParentBottom=\"true\"  \n\t\t    android:layout_marginBottom=\"50dp\"  \n\t\t    android:layout_marginLeft=\"120dp\"  \n\t\t    android:text=\"Broadcast Intent\" \" /> \n\n\t![img](images/2.0/setup/image171.jpg)  \n3. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image172.jpg) \n4. Declare a variable inside \"MainActivity\" to store \"buttonBroadcastIntent\". \n\n\t\t:::java\n\t\t//Declare a variable to store the buttonBroadcastIntent  \n\t\tprivate Button buttonBroadcastIntent = null;  \n\n\t![img](images/2.0/setup/image173.jpg)  \n5. Inside \"onCreate\" get a reference to \"buttonBroadcastIntent\".\n\n\t\t:::java\n\t\t//Get the buttonBroadcastIntent  \n\t\tbuttonBroadcastIntent = (Button) findViewById(R.id.buttonBroadcastIntent); \n\n\t![img](images/2.0/setup/image174.jpg)  \n6. Inside \"onCreate\" add an \"OnClickListener\" for \"buttonMSR\".  \n\n\t\t:::java\n\t\t//Add an OnClickListener for buttonBroadcastIntent  \n\t\tbuttonBroadcastIntent.setOnClickListener(buttonBroadcastIntentOnClick);  \n\n\t![img](images/2.0/setup/image175.jpg)  \n7. Add a new \"OnClickListener\" inside \"MainActivity\".  \n\n\t\t:::java\n\t\t//OnClickListener for buttonBroadcastIntent  \n\t\tprivate OnClickListener buttonBroadcastIntentOnClick = new OnClickListener() {  \n\t\t    public void onClick(View v) {  \n\t\t  \n\t\t    }  \n\t\t};  \n\n\t![img](images/2.0/setup/image176.jpg)  \n8. Add the following code to \"onClick\" to launch \"BroadcastIntentActivity\". \n\n\t\t:::java\n\t\t//Launch BroadcastIntentActivity  \n\t\tIntent myIntent = new Intent(MainActivity.this, BroadcastIntentActivity.class);  \n\t\tstartActivity(myIntent);  \n\n\t![img](images/2.0/setup/image177.jpg) \n\n###Creating Broadcast Intent UI\nThen we will create the UI for displaying Barcode data to the user. \n\n1. Select \"activity_msr.xml\" from \"Package Explorer\" in Eclipse.  \n\n\t![img](images/2.0/setup/image178.jpg) \n2. Remove the default \"TextView\". \n3. Add the following TextView. \n\n\t\t:::xml\n\t\t<TextView  \n\t\t    android:id=\"@+id/textViewData\"  \n\t\t    android:layout_width=\"wrap_content\"  \n\t\t    android:layout_height=\"wrap_content\"  \n\t\t    android:layout_alignParentTop=\"true\"  \n\t\t    android:layout_centerHorizontal=\"true\"  \n\t\t    android:layout_marginTop=\"50dp\"  \n\t\t    android:text=\"Please Scan a Barcode.\"  \n\t\t    android:textAppearance=\"?android:attr/textAppearanceMedium\" />  \n\n\t![img](images/2.0/setup/image179.jpg) \n\n###Creating our Broadcast Intent Profile\nNext will will create a Data Capture profile that will be active on \"BroadcastIntentActivity\" and send Barcode data using a Broadcast Intent. \n\n1. Select \"EMDKSample\" project from Package Explorer.    \n2. Click \"EMDK\" menu and select \"Profile Manager\".  \n    ![img](https://launchpad-images.s3-us-west-1.amazonaws.com/emdk/setup/image043.jpg)  \n3. The EMDK Profile Manager Window will appear.  \n    ![img](images/2.0/setup/image180.jpg)  \n4. click \"Create\".  \n    ![img](images/2.0/setup/image181.jpg)  \n5. Enter the Profile Name \"DataCaptureProfileBroadcastIntent\" and click \"Create\".  \n    ![img](images/2.0/setup/image182.jpg)  \n6. select \"ActivitySelection\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow.  \n    ![img](images/2.0/setup/image142.jpg)  \n7. Select \"Activity Selection\".  \n    ![img](images/2.0/setup/image143.jpg)  \n8. Enter \"com.symbol.emdksample\" as the application name and click apply.  \n    ![img](images/2.0/setup/image144.jpg)  \n9. Enter \"BroadcastIntentActivity\" as the activity name and click apply.  \n    ![img](images/2.0/setup/image183.jpg)  \t\n10. Click Okay.  \n11. select \"Barcode\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow. \n    ![img](images/2.0/setup/image184.jpg)  \t\n12. Change \"Barcode Scanner Input Enable\" to \"Enable\".  \n\t![img](images/2.0/setup/image185.jpg)  \n13. select \"Intent\" from the list of \"Available Features\" and add it to \"Selected Features\" using the arrow. \n\t![img](images/2.0/setup/image186.jpg) \n14. Now we will configure the \"Intent\" settings.  \n\t* Switch \"Intent Output Enable\" to Enable\". \n\t* For \"Intent Output Action\" enter \"com.symbol.emdksample.RECVRBI\".\n\t* Switch \"Intent Output Delivery\" to \"Broadcast Intent\".  \n\t* Switch \"Basic data formatting Enable\" to Enable\". \n\t* Switch \"Basic data formatting Send Data\" to Enable\". \t\n\n\tYour Intent configuration should now look like this:  \n\t![img](images/2.0/setup/image187.jpg)  \n\n15. Click \"Apply\" and \"Finish\".  \n    ![img](images/2.0/setup/image188.jpg)  \n16. Click \"Close\".  \n    >Note:  \n    >Now the \"EMDKConfig.xml\" file under the \"\\assets\" folder will be updated with your changes.\n\n###Registering for the Broadcast Intent profile\nNow will register our new Data Capture profile in \"MainActivity\".\n\n1. Select \"MainActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image189.jpg) \n2. Inside \"MainActivity\" add the following code to hold the name of our Broadcast Intent profile.  \n\n\t\t:::java\n\t\t//Assign the profile name used in EMDKConfig.xml  for Broadcast Intent handling  \n\t\tprivate String profileNameBroadcastIntent = \"DataCaptureProfileBroadcastIntent\";\n\t\n    ![img](images/2.0/setup/image190.jpg)  \n3. Inside \"onOpened\" add the following code to register the Broadcast Intent EMDK profile. \n\n\t\t:::java\n\t\t//Call processPrfoile for profile Broadcast Intent.  \n\t\tresults = mProfileManager.processProfile(profileNameBroadcastIntent, ProfileManager.PROFILE_FLAG.SET, modifyData);  \n\t\t  \n\t\tif(results.statusCode == STATUS_CODE.FAILURE)  \n\t\t{  \n\t\t//Failed to set profile  \n\t\t}  \n\n    ![img](images/2.0/setup/image191.jpg)  \n\n###Handling Broadcast Intents\nNewt we will add the code to listen for our Broadcast Intent and display the Barcode data to the user in side \"BroadcastIntentActivity\". \n\n1. Select \"BroadcastIntentActivity.java\" from \"Package Explorer\" in Eclipse. \n\n\t![img](images/2.0/setup/image192.jpg)  \n2. Add the following imports.  \n\n\t\t:::java\n\t\timport android.content.BroadcastReceiver;  \n\t\timport android.content.Context;  \n\t\timport android.content.Intent;  \n\t\timport android.content.IntentFilter;  \n\t\timport android.widget.TextView;  \n\n\t![img](images/2.0/setup/image193.jpg)  \n3. Add a global variable for the TextView. \n\n\t\t:::java\n\t\t//Declare a variable to store the textViewData  \n\t\tprivate TextView textViewData = null;  \n\t\n\t![img](images/2.0/setup/image194.jpg)\n4. Add the following code to your onCreate function to get a handle on the TextView.\n\n\t\t:::java\n\t\t//Get the textViewData  \n\t\ttextViewData = (TextView) findViewById(R.id.textViewData);  \n\n\t![img](images/2.0/setup/image195.jpg)  \n5. Add a global variable to BroadcastIntentActivity to hold our Broadcast Receiver.\n\n\t\t:::java\n\t\t//Declare a variable to store our Broadcast Receiver.  \n\t\tprivate BroadcastReceiver EMDKReceiver;  \n     \n    ![img](images/2.0/setup/image196.jpg)  \n6. Override \"onResume\".  \n\n\t\t:::java\n\t\t@Override  \n\t\tprotected void onResume() {  \n\t\t// TODO Auto-generated method stub  \n\t\t    super.onResume();  \n\t\t} \n\n    ![img](images/2.0/setup/image197.jpg)  \n7. Override \"onPause\".  \n\n\t\t:::java\n\t\t@Override  \n\t\tprotected void onPause() {  \n\t\t    // TODO Auto-generated method stub  \n\t\t    super.onPause();  \n\t\t} \n\n    ![img](images/2.0/setup/image198.jpg)   \n8. Add the following code to \"onResume\" to create an Intent filter.  \n\n\t\t:::java\n\t\t//Create an Intent Filter  \n\t\tIntentFilter intentFilter = new IntentFilter(\"com.symbol.emdksample.RECVRBI\");\n\n\t![img](images/2.0/setup/image199.jpg) \n9. Add the following code to \"onResume\" to create a Broadcast Receiver.  \n\n\t\t:::java\n\t\t//Create a our Broadcast Receiver.  \n\t\tEMDKReceiver = new BroadcastReceiver() {  \n\t\t  \n\t\t};  \n\n\t![img](images/2.0/setup/image200.jpg)   \n10. Override \"onReceive\" inside the Broadcast Receiver.  \n\n\t\t:::java\n\t\t@Override  \n\t\tpublic void onReceive(Context context, Intent intent) {  \n\t\t  \n\t\t} \n\n\t![img](images/2.0/setup/image201.jpg)  \n11. Add the following code to \"onReceive\" to check if the data is coming from the Barcode scanner.  \n\n\t\t:::java\n\t\t//Get the source of the data  \n\t\tString source = intent.getStringExtra(\"com.motorolasolutions.emdk.datawedge.source\");  \n\t\t  \n\t\t//Check if the data has come from the barcode scanner  \n\t\tif(source.equalsIgnoreCase(\"scanner\")){  \n\t\t  \n\t\t} \n\n\t![img](images/2.0/setup/image202.jpg)  \n12. Add the following code to get the data from the intent.  \n\n\t\t:::java\n\t\t//Get the data from the intent  \n\t\tString data = intent.getStringExtra(\"com.motorolasolutions.emdk.datawedge.data_string\");  \n\t\t  \n\t\t//Check that we have received data  \n\t\tif(data != null && data.length() > 0){  \n\t\t  \n\t\t}\n\n\t![img](images/2.0/setup/image203.jpg)  \n13. Add the following code to display the data to the TextView.  \n\n\t\t:::java\n\t\t//Display the data to the text view  \n\t\ttextViewData.setText(\"Data = \" + data);  \n\n\t![img](images/2.0/setup/image204.jpg)  \n14. Add the following code to \"onResume\" to register our receiver.  \n\n\t\t:::java\n\t\t//Register our receiver.\n\t\tthis.registerReceiver(EMDKReceiver, intentFilter);\n\n\t![img](images/2.0/setup/image205.jpg)  \n15. Add the following code to \"onPause\" to unregister our receiver.  \n\n\t\t:::java\n\t\t//Register our receiver.\n\t\tthis.registerReceiver(EMDKReceiver, intentFilter);\n\n\t![img](images/2.0/setup/image206.jpg)  \n\n###Running the Application###\nLastly we will run and test our application. \n\n1. Connect Motorola Solutions Android device (having the latest EMDK runtime) to the USB port.\n\n    >Note:   \n    >Make sure the device is in USB debug.\n\n2. Run the application.  \n\n\t![img](images/2.0/setup/image207.png)  \n3. Press the trigger button and scan a Barcode.  \n\n\t![img](images/2.0/setup/image208.png)  \n4. Like before the scanned data will be populated in the Edit Text field Through the previous Keystroke Intent and will appear on the TextView using the previous Datawedge Intent.   \n5. Press the button \"Broadcast Intent\".  \n\n\t![img](images/2.0/setup/image209.png)  \n6. Scan a Barcode.  \n\n\t![img](images/2.0/setup/image210.png)  \n8. The TextView will be populated by the Broadcast Intent.\n7. Press the back button to rerun to the main screen.  \n\n\t![img](images/2.0/setup/image208.png)  \n9. Press the button \"MSR\", like before the MSR screen will come up.  \n\n\t![img](images/2.0/setup/image171.png)\n10. Swipe a cad through the MSR.  \n\n\t![img](images/2.0/setup/image172.png)\n11. Press return to go back to the MSR where you can swipe another card, or hit return again to go back to the main screen. \n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-UsingBroadcastIntentinDataCaptureProfiles.zip)."},{"key":"guide-tutorial-tutModifyBarcodeProfileSettings","name":" Modifying Profiles With ProfileConfig API","md":"# Modifying Profiles With ProfileConfig API\n\n## Overview\nThis guide will walk you through creating an EMDK For Android application that will make use [Profile Config](#api-ProfileConfig) object to modify Profile Settings programatically in order to get barcode data into your application using the [KeyStroke output](#guide-profiles-profilekeystroke) feature of [EMDK Profiles](#guide-profiles-usingwizard).\n\n###Prerequisites###\n\n* Java Development Kit (JDK)\n* Android Developer Tools (ADT)\n* Motorola EMDK for Android 2.0 and above\n\nFor more information about setting up the EMDK please see the EMDK Overview.\n\n## Creating The Project\n1.Create new Android Application project.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/create_android_project.jpg)\n\n2.Assign names for the application and package. \n\n3.Set the minimum required SDK to \"API 16: Android 4.1 (Jelly Bean)\".\n  \n![img](images/2.0/modify_profile_settings_images/2.0/provide_project_name.jpg)\n\n4.Click \"Next\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/configure_project.jpg)  \n\n5.Click \"Next\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/configure_launcher_icon.jpg) \n \n6.Click \"Next\".  \n7.Select \"Empty Activity\" Click \"Next\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/create_activity.jpg)  \n\n   >\n   >:  \n   >If \"Empty Activity\" is not available make sure you are using \"Android SDK Tools 22.6.3\" and \"Android SDK Platform Tools 19.0.2\"\n\n8.Click \"Next\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/empty_activity.jpg)  \n\n9.Click \"Finish\".\n\n   >Note:  \n   >Currently there is nothing under \"\\assets\" folder.  \n    \n![img](images/2.0/modify_profile_settings_images/2.0/main_activity.jpg)  \n\n## Enabling the EMDK\n1.Select the project.  \n2.Select \"File -> Properties\" or right click on the project and select \"Properties\".\n  \n![img](images/2.0/modify_profile_settings_images/2.0/project_propertiies_button1.jpg)   \n\n![img](images/2.0/modify_profile_settings_images/2.0/project_propertiies_button2.jpg)\n   \n3.Click \"Android\" from the left pane. \n \n![img](images/2.0/modify_profile_settings_images/2.0/project_properties.jpg) \n\n4.Select \"Motorola Solutions EMDK v2.0\" from the list of Project Build Targets.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/project_build_target.jpg)  \n\n   >Note:  \n   >If \"Motorola Solutions EMDK v2.0\" is not on the list of Build Tagets, please confirm you have installed Android API 16 SDK Platform.\n\n5.Click \"Apply\" and \"OK\".  \n   >Note:  \n   >The EMDK library will be \n   >added to the project.  \n    \n![img](images/2.0/modify_profile_settings_images/2.0/emdk_library_added.jpg) \n\n   >Note:\n   >If you are using Java 1.7 as the compiler, you may see this error\n    \n![img](images/2.0/modify_profile_settings_images/2.0/java_compiler_error.jpg) \n\n   > To correct this, you will need to change the compiler to use 1.6\n    \n   > * Click on the Java Compiler\n   > * Click Enable project specific settings\n   > * Select 1.6 for Compiler compliance level\n    \n![img](images/2.0/modify_profile_settings_images/2.0/change_java_compiler_settings.jpg) \n\n## Adding a DataCapture Profile\n1.Select \"ModifyBarcodeProfileTutorial\" project from Package Explorer.    \n2.Click \"EMDK\" menu and select \"Profile Manager\".\n  \n![img](images/2.0/modify_profile_settings_images/2.0/emdk_manager_button.jpg)\n  \n3.The EMDK Profile Manager Window will appear.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/profile_manager_create.jpg) \n \n4.Click \"Create\" and assign a name for the profile (Ex: ModifyBarcodeProfile).\n  \n![img](images/2.0/modify_profile_settings_images/2.0/create_new_profile.jpg)\n  \n5.Click \"Create\". The Profile Editor window will appear.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/profile_editor.jpg)\n  \n6.Select any feature from the list and click \"Right Arrow\" (Ex: \"ActivitySelection\" has been selected. By using this feature Activities can be associated with the application. Then the data capture feature will be enabled automatically when the specified activity is in foreground).\n  \n![img](images/2.0/modify_profile_settings_images/2.0/activity_selection.jpg)\n  \n7.Click on the selected feature. The parameter list will be populated.  \n\n![img](images/2.0/modify_profile_settings_images/2.0/activity_selection_parameters.jpg)\n  \n8.Click \"ActivitySelection\" under parameters.  \n\n![img](images/2.0/modify_profile_settings_images/2.0/activity_selection_parameter_package_name.jpg)  \n\n9.Specify the applications package name and click \"Apply\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/activity_selection_parameter_activity_name.jpg) \n \n10.Specify an Activity inside the application and click \"Apply\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/activity_selection_done.jpg)  \n\n11.Click \"OK\".  \n12.Select any data capture feature and click Right Arrow (Ex: \"Barcode\" has been selected).\n  \n![img](images/2.0/modify_profile_settings_images/2.0/barcode.jpg)\n  \n13.Click on the \"Barcode\" feature. The parameter list will be populated. \n \n![img](images/2.0/modify_profile_settings_images/2.0/barcode_profile_editor.jpg)\n  \n14.Enable the feature and change some parameters.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/barcode_select_scanner_type.jpg)\n  \n![img](images/2.0/modify_profile_settings_images/2.0/barcode_select_decoders.jpg)\n  \n15.Click \"Apply\". \n\n16.Select the Keystroke feature and click \"Right Arrow\" (Ex: \"Keystroke\" has been selected).\n  \n![img](images/2.0/modify_profile_settings_images/2.0/keystroke_editor.jpg)  \n\n17.Enable the feature and change some parameters. \n \n![img](images/2.0/modify_profile_settings_images/2.0/enable_keystroke.jpg)\n  \n![img](images/2.0/modify_profile_settings_images/2.0/enable_keystroke_data_formatting.jpg)\n  \n18.Click \"Apply\" and \"Finish\".  \n\n![img](images/2.0/modify_profile_settings_images/2.0/profile_editing_done.jpg) \n \n19.Click \"Close\".  \n\n   > Note: \n   > Now the \"EMDKConfig.xml\" is created under \"\\assets\" folder. This file will contain a definition of all of your profiles that you create. \n    \n![img](images/2.0/modify_profile_settings_images/2.0/emdk_config_file.jpg)\n  \n20.You can inspect the EMDKConfig.xml to see it is reflecting the changes made to the parameters via EMDK Profile Manager GUI earlier.  However, it is advised that this file not be manually updated and only be controlled via the Profile Manager.\n\n![img](images/2.0/modify_profile_settings_images/2.0/emdk_config_activity_selection_changes.jpg)\n   \n![img](images/2.0/modify_profile_settings_images/2.0/emdk_config_keystroke_changes.jpg)   \n\n## Enabling Android Permissions\n1.Modify the Application's Manifest.xml to use the EMDK library and to set permission for the EMDK. \n \n![img](images/2.0/modify_profile_settings_images/2.0/manifest_file_default.jpg)\n\nYou must first enable permissions for 'com.symbol.emdk.permission.EMDK':\n  \n    \t:::xml\n    \t<uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n\nThen you must enable the library:\n  \n\t\t:::xml\n\t\t<uses-library android:name=\"com.symbol.emdk\" />\n\nWhen done, your manifest.xml should look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/manifest_file_updated.jpg)  \n\n##Adding Some Code    \n1.Now we will start to add some code. \n\nFirst you must add references to the libraries:\n  \n\t\t:::java\n\t\timport com.symbol.emdk.*;\n    \timport com.symbol.emdk.EMDKManager.EMDKListener;\n\nThen you must extend the activity to implement EMDKListener. Use Eclipse's Content Assist to implement the unimplemented functions of `onOpened` and `onClosed`.    \n    \n\t\t:::java\n\t\tpublic class MainActivity extends Activity implements EMDKListener {\n         .. .. .. .. .. .. ...\n\n        @Override\n        public void onClosed() {\n\n               // TODO Auto-generated method stub\n\n        }\n        @Override\n        public void onOpened(EMDKManager emdkManager) {\n\n               // TODO Auto-generated method stub\n\n         }\n\t\t}\t\t    \n\n    \n We will now create some global variables to hold the profile name as well as instance objects of EMDKManager and ProfileManager that we will use throughout the code:\n\n\t\t:::java\n\t\t//Assign the profile name used in EMDKConfig.xml\n    \tprivate String profileName = \"ModifyBarcodeProfile\";\n\n    \t//Declare a variable to store ProfileManager object\n    \tprivate ProfileManager profileManager = null;\n\n    \t//Declare a variable to store EMDKManager object\n    \tprivate EMDKManager emdkManager = null;\n\t\t\nIn the onCreate method, we call getEMDKManager so that the EMDK can be initialized and checked to see if it is ready. \n\n\t\t:::java\n\t\t// The EMDKManager object creation\n\t\t// The EMDKManager object will be returned in the callback.\n\t\tEMDKResults results = EMDKManager.getEMDKManager(\n\t\t\t\tgetApplicationContext(), this);\n\n\t\t// Check the return status of processProfile\n\t\tif (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t  // EMDKManager object creation success\n\n\t  \t} else {\n\n\t\t  // EMDKManager object creation failed\n\t  \t}\n    \nSo far your code should look like:\n     \n![img](images/2.0/modify_profile_settings_images/2.0/main_activity_declare_profile_name.jpg) \n\n2.Now we need to use the `onOpened` method to get a reference to the EMDKManager. The EMDKListener interface will trigger this event when the EMDK is ready to be used. This must be implemented in order to get a reference to the EMDKManager APIs. This event will pass the EMDKManager instance and we assign it to the global variable `emdkManager` that we created in the previous steps. We then use that instance object to get an instance of ProfileManager and assign it to the global variable `profileManager`. This is how we will interface with the APIs in the rest of the code:\n  \n\t\t:::java\n\t\tthis.emdkManager = emdkManager;\n\n        //Get the ProfileManager object to process the profiles\n        profileManager = (ProfileManager) emdkManager.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n   > Note: \n   > Sometimes the default parameter in `onOpened` method is `arg0`. So you have to rename that parameter to `emdkManager`.\n    \nNow that we have a reference to ProfleManager, we use it to install and activate the profile we built earlier using the `processProfile` method. We could have also performed this action at a different time, say when someone pressed a button, but we chose to do it as soon as the EMDK was ready:\n\nSo the `onOpened` method now looks like:\n\n\t\t:::java\n\t\t@Override\n\t\tpublic void onOpened(EMDKManager emdkManager) {\n\t\t this.emdkManager = emdkManager;\n\n\t\t  // Get the ProfileManager object to process the profiles\n\t\t  profileManager = (ProfileManager) emdkManager\n\t\t\t\t.getInstance(EMDKManager.FEATURE_TYPE.PROFILE);\n\n\t\t  String[] modifyData = new String[1];\n\n\t\t  // Call processPrfoile with profile name and SET flag to create the\n\t\t  // profile. The modifyData can be null.\n\t\t  EMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.SET, modifyData);\n\n\t\t  // Check the return status of processProfile\n\t\t  if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\t\t\tToast.makeText(MainActivity.this, \"Profile initilization Success\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\n\t\t  } else {\n\t\t\tToast.makeText(MainActivity.this, \"Profile initilization failed\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t  }\n\n\t\t}   \n \nYour onOpened method should now look like this:\n    \n![img](images/2.0/modify_profile_settings_images/2.0/onopened_method.jpg)  \n    \n3.Now let's override the \"onDestroy\" method so we can release the EMDKManager resources:\n\n\t\t:::java\n\t\t@Override\n\t\tprotected void onDestroy() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tsuper.onDestroy();\n\t\t\n\t\t\t// Clean up the objects created by EMDK manager\n\t\t\temdkManager.release();\n\t\t}\n\nYour onDestroy method should now look like this: \n\n![img](images/2.0/modify_profile_settings_images/2.0/on_destroy_method.jpg) \n\n4.Now lets add some of the string values in \"res/values/strings.xml\" that we would be using in our layout files.\n\n\t\t:::xml\n\t\t<string name=\"code128_string\">Code128</string>\n\t    <string name=\"code39_string\">Code39</string>\n\t    <string name=\"EAN8_string\">EAN8 </string>\n\t    <string name=\"EAN13_string\">EAN13 </string>\n\t    <string name=\"UPCE_string\">UPCA </string>\n\t    <string name=\"UPCE0_string\">UPCE0 </string>\n\t    <string name=\"button_set_string\">Update Settings </string>\n\nYour strings.xml file should now look like this:  \n\n![img](images/2.0/modify_profile_settings_images/2.0/declare_strings.jpg)\n\n5.Remove the default code, inside \"res/layout/activity_main.xml\".\n\n6.add the following code, inside \"res/layout/activity_main.xml\". This code contains some checkboxes that represent some of the barcode types. We will change the status of these barcode types \"Enable/Disable\" programatically.\n\nThe code also contains a Drop-Down (Spinner) that we would be using to select a specific type of barcode scanner device programatically.\n\nAt the bottom, the layout file contains a button \"Update Settings\" that is used to apply settings selected by the user.\n\n\t\t:::xml\n\t\t<ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:layout_width=\"fill_parent\"\n\t    android:layout_height=\"fill_parent\" >\n\n\t      <RelativeLayout\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"wrap_content\"\n\t        android:padding=\"10dip\" >\n\n\t        <Button\n            android:id=\"@+id/btn_barcode\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_centerHorizontal=\"true\"\n            android:layout_margin=\"10dip\" />\n\n\t        <Spinner\n            android:id=\"@+id/scanner_type_spinner\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/btn_barcode\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxEAN8\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentLeft=\"true\"\n            android:layout_below=\"@+id/scanner_type_spinner\"\n            android:layout_marginBottom=\"5dip\"\n            android:layout_marginLeft=\"5dip\"\n            android:layout_marginRight=\"5dip\"\n            android:layout_marginTop=\"20dp\"\n            android:checked=\"true\"\n            android:enabled=\"true\"\n            android:text=\"@string/EAN8_string\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxEAN13\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentRight=\"true\"\n            android:layout_below=\"@+id/scanner_type_spinner\"\n            android:layout_marginBottom=\"5dip\"\n            android:layout_marginLeft=\"5dip\"\n            android:layout_marginRight=\"12dip\"\n            android:layout_marginTop=\"20dip\"\n            android:text=\"@string/EAN13_string\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxUPCA\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentLeft=\"true\"\n            android:layout_below=\"@+id/checkBoxEAN8\"\n            android:layout_margin=\"5dip\"\n            android:checked=\"true\"\n            android:enabled=\"true\"\n            android:text=\"@string/UPCE_string\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxUPCE0\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentRight=\"true\"\n            android:layout_below=\"@+id/checkBoxEAN13\"\n            android:layout_marginBottom=\"5dip\"\n            android:layout_marginLeft=\"5dip\"\n            android:layout_marginRight=\"12dip\"\n            android:layout_marginTop=\"5dip\"\n            android:text=\"@string/UPCE0_string\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxCode128\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentLeft=\"true\"\n            android:layout_below=\"@+id/checkBoxUPCA\"\n            android:layout_margin=\"5dip\"\n            android:checked=\"true\"\n            android:enabled=\"true\"\n            android:text=\"@string/code128_string\" />\n\n\t        <CheckBox\n            android:id=\"@+id/checkBoxCode39\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_alignParentRight=\"true\"\n            android:layout_below=\"@+id/checkBoxUPCE0\"\n            android:layout_margin=\"5dip\"\n            android:text=\"@string/code39_string\" />\n\n\t        <EditText\n            android:id=\"@+id/editText\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/checkBoxCode39\"\n            android:layout_margin=\"10dip\"\n            android:ems=\"5\"\n            android:inputType=\"none\"\n            android:scrollbars=\"vertical\" />\n\n\t        <Button\n            android:id=\"@+id/btn_set\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_below=\"@+id/editText\"\n            android:layout_centerHorizontal=\"true\"\n            android:layout_margin=\"20dip\"\n            android:text=\"@string/button_set_string\" />\n\t\t  </RelativeLayout>\n\t\t</ScrollView>\t\t\n\t\nYour activity_main.xml file should now look like this:\n\n![img](images/2.0/modify_profile_settings_images/2.0/create_layout.jpg)\n    \n7.Next, we will declare these UI elements in our activity class by writing following code in \"MainActivity.java\" class.\n  \n\t\t:::java\n\t\t// CheckBox for Barcode type 128\n\t\tprivate CheckBox checkBoxCode128;\n\t\t// CheckBox for Barcode type 39\n\t\tprivate CheckBox checkBoxCode39;\n\t\t// CheckBox for Barcode type EAN8\n\t\tprivate CheckBox checkBoxEAN8;\n\t\t// CheckBox for Barcode type EAN13\n\t\tprivate CheckBox checkBoxEAN13;\n\t\t// CheckBox for Barcode type UPCA\n\t\tprivate CheckBox checkBoxUPCA;\n\t\t// CheckBox for Barcode type UPCE0\n\t\tprivate CheckBox checkBoxUPCE0;\n\t\n\t\t// Drop down that displays a list of available types of scanners\n\t\tprivate Spinner scannerTypeSpinner;\n\t\n\t\t// Button for updating changes made in the barcode types.\n\t\tprivate Button setButton;\n\t\n\t\t// Button to specify current status of the Barcode.\n\t\tprivate Button barcodeStatusButton;\n\t\t\n\n   >Note:\n   >Press CTRL+SHIFT+O or CMD+SHIFT+O for organizing imports.\n\nSo declaration of UI elements would look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/declare_ui_elements.jpg)\n\n\n8.We will now get reference of these UI elements in the 'onCreate()' method of 'MainActivity.java' class as follows:\n\n\n\t\t:::java\n\t\t// Get references of the checkboxes declared in the UI\n\t\tcheckBoxCode128 = (CheckBox) findViewById(R.id.checkBoxCode128);\n\t\tcheckBoxCode39 = (CheckBox) findViewById(R.id.checkBoxCode39);\n\t\tcheckBoxEAN8 = (CheckBox) findViewById(R.id.checkBoxEAN8);\n\t\tcheckBoxEAN13 = (CheckBox) findViewById(R.id.checkBoxEAN13);\n\t\tcheckBoxUPCA = (CheckBox) findViewById(R.id.checkBoxUPCA);\n\t\tcheckBoxUPCE0 = (CheckBox) findViewById(R.id.checkBoxUPCE0);\n\n\t\t// Get references of all the buttons declared in the UI\n\t\tsetButton = (Button) findViewById(R.id.btn_set);\n\t\tbarcodeStatusButton = (Button) findViewById(R.id.btn_barcode);\n\n\t\t// Get the reference scanner type spinner\n\t\tscannerTypeSpinner = (Spinner) findViewById(R.id.scanner_type_spinner);\n\t\t\nThe onCreate() method at this point should look like this:\n\n![img](images/2.0/modify_profile_settings_images/2.0/references_of_ui_elements.jpg)\n\n9.In the next step, we will set the list of scanning devices in the drop down [Spinner](http://developer.android.com/guide/topics/ui/controls/spinner.html)\n\nIn order to implement that, we have created an 'Arraylist' of Strings that contains the list of scanner devices that the user can select to scan Barcodes. This list will be set in an Array Adapter.\n\nWe have implemented an 'on item selected listener' for this spinner, which would select respective type of scanning device programatically.\n\nAdd the following code in the onCreate() method after references of UI elements:\n\n\t\t:::java\n\t\t// List that contains supported scanning device types\n\t    List<String> scannerTypeList = new ArrayList<String>();\n\t\tscannerTypeList.add(\"AUTO\");\n\t\tscannerTypeList.add(\"INTERNAL_LASER1\");\n\t\tscannerTypeList.add(\"INTERNAL_IMAGER1\");\n\t\tscannerTypeList.add(\"INTERNAL_CAMERA1\");\n\t\n\t\t// Adapter to hold the list of scanning device types.\n\t\tArrayAdapter<String> dataAdapter = new ArrayAdapter<String>(this,\n\t\t\t\tandroid.R.layout.simple_spinner_item, scannerTypeList);\n\t\tdataAdapter\n\t\t\t\t.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\n\t\t// Set the dapater to the spinner\n\t\tscannerTypeSpinner.setAdapter(dataAdapter);\n\n\t\t// On Item Selected Listener of Spinner items.\n\t\tscannerTypeSpinner\n\t\t\t\t.setOnItemSelectedListener(new OnItemSelectedListener() {\n\n\t\t@Override\n\t\tpublic void onItemSelected(AdapterView<?> parent,\n\t\t\t\t\t\t\tView view, int position, long id) {\n\n\t\t\t// Set the user selected device type as scanning device.\n\t\t\tsetDeviceType(parent.getItemAtPosition(position)\n\t\t\t\t\t\t\t\t.toString());\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\t}\n\t\t});\n\n        \nThe onCreate() method should now look like this:\n\n![img](images/2.0/modify_profile_settings_images/2.0/drop_down_details.jpg)\n\n\n10.The method 'setDeviceType()' takes the position of the user selected device type from the drop down and modifies the profile settings by accessing Profile Manager API.\n \nIn order to get access to the Profile Manager's API, EMDK provides three ways:   \n    \n* Document - data will be handled as a XML Document\n* String - data will be handled as a raw string\n* ProfileConfig - data will be handled as a ProfileConfig class \n      \nThe preferred way is to use the profileConfig option and the examples below present using such option. Using the Document or String methods may not work if the XML is not structured properly.\n\nSo, we will create reference of 'ProfileConfig' in the MainActivity.java class.\n\n\t\t:::java\n\t\t// Profile Config reference for modifying Profiles.\n\t    private ProfileConfig profileConfigObj = null;\t\t\n\nThis would look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/profile_config_declaration.jpg)\n\n11.In the 'setDeviceType method, we create an object of 'ProfileConfig' class. To modify a profile, we would:\n  * Use the PROFILE_FLAG.GET option to retrieve the profile (if it exists)\n  * Use the profileConfig Object and APIs to modify the settings\n  * Use the PROFILE_FLAG.SET option to save the settings.\nThe user would be notified via [Toast](http://developer.android.com/guide/topics/ui/notifiers/toasts.html) if the profile does not exist.\n\nThe method accepts a String argument, which is the type of scanning device selected by the user from drop down. Based on this parameter, the problemConfig object would be modified and set to the user selected device type.\n\nHere's the code for selecting specific type of scanning device programatically by  modifying the profileConfig object in 'setDeviceType' method.  \n\n\t\t:::java\n\t\t// Sets the scanner device type selected by user from the spinner\n\t\tpublic void setDeviceType(String deviceType) {\n\t\t // Create the ProfileConfig object\n\t\t profileConfigObj = new ProfileConfig();\n\t\t // Get the ProfileConfig from the profile XML\n\t\t EMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\n\t\t // Check the return status of processProfile\n\t\t if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\t\t\tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\treturn;\n\t\t }\n\t\t // Set the profile config object to the user selected device type from\n\t\t // the spinner\n\t\t if (deviceType.equalsIgnoreCase(\"AUTO\")) {\n\t\t\tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.AUTO;\n\t\t } else if (deviceType.equalsIgnoreCase(\"INTERNAL_LASER1\")) {\n\t\t\tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_LASER1;\n\t\t } else if (deviceType.equalsIgnoreCase(\"INTERNAL_CAMERA1\")) {\n\t\t\tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_CAMERA1;\n\t\t } else {\n\t\t\tprofileConfigObj.dataCapture.barcode.scannerSelection = DEVICETYPES.INTERNAL_IMAGER1;\n\t\t }\n\t\t // Call processPrfoile with profile name, SET flag and config data\n\t\t // to update the profile\n\t\t results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\n\t\t // Check the return status of processProfile\n\t\t if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t// Device type selected\n\n\t\t } else {\n\n\t\t\t// Failed to select device type\n\t\t }\n\t\t}\n\n\nSo the method would look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/set_device_type_method.jpg)\n\n12.Similarly we would now use this 'profileConfig' object for modifying other parameters. one of these will be to check the status of the barcode (Enable/Disable)\n\nOnce the profile is retrieved using 'PROFILE_FLAG.GET', we will check 'profileConfigObj.dataCapture.barcode.scanner_input_enabled' parameter in the 'checkBarcodeStatus' method and set the status on the 'barcodeStatusButton'. This method is called when the EMDK Manager is ready in the 'onOpened()' method of the 'MainActivity.java' file.\n\ncall 'checkBarcodeStatus()' method from 'onOpened()' method\n\n\t\t:::java\n\t\tcheckBarcodeStatus();\n\nSo the complete onOpened() method looks like this:\n\n![img](images/2.0/modify_profile_settings_images/2.0/check_barcode_status_method_call.jpg)\n\nThe code for checkBarcodeStatus() method looks like this:\n\n\t\t:::java\n\t\t// Check and display the status of the Barcode on the button\n\t\t// (Enable/Disable)\n\t\tpublic void checkBarcodeStatus() {\n\t\t // Create the ProfileConfig object\n\t\t profileConfigObj = new ProfileConfig();\n\n\t\t // Get the ProfileConfig from the profile XML\n\t\t EMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\n\t\t // Check the return status of processProfile\n\t\t if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\n\t\t\tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\treturn;\n\n\t\t }\n\n\t\t if (profileConfigObj.dataCapture.barcode.scanner_input_enabled == ENABLED_STATE.FALSE) {\n\t\t\tbarcodeStatusButton.setText(\"Enable Barcode\");\n\t\t } else {\n\t\t\tbarcodeStatusButton.setText(\"Disable Barcode\");\n\t\t }\n\n\t\t}\t\t\n\nThe checkBarcodeStatus() method finally looks like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/check_barcode_status_method.jpg)\n  \n\n13.Apart from this, we have few checkboxes that represent different types of barcode and two buttons 'Barcode' and 'Update Settings'.\n    \nLets concentrate on the top button that allows user to Enable/Disable Barcode scanning programatically using profileConfig object. If the scanning is enabled, the user can disable it by pressing 'Disable Barcode' button so that the application will not be able to scan any barcode. If the scanning is disabled, the user can enable it by pressing 'Enable Barcode' button.\n\nThe checkboxes represent different types of barcode types that can be scanned using this application. The user can select the desired types of barcodes that need to be scanned by the application.\n\nOnce the checkboxes have been selected, the user will press 'Update Profile' button that would update the profile settings based on users selection.\n\nSo we will implement both of these functionalities using 'profileConfig' object. \n\nIn order to implement this, we need to implement 'on click listener' of both of these buttons. We can do it by writing a common 'on click' method and perform operations based on the button ID's.\n\nSo we will set the 'on click listener' on these two buttons using following code:\n\n\t\t:::java\n\t\t// Set the on click listeners on buttons\n\t    setButton.setOnClickListener(onClickListener);\n\t    barcodeStatusButton.setOnClickListener(onClickListener);\t\t\n\nThis makes the onCreate() method looks like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/button_on_click_declaration.jpg)\n\nWe would now write the on click listener that has the common onclick method in which we have called the respective operations based on button ID's.\n\n\t\t:::java\n\t\t// Common on Click Listener for all buttons\n\t\tprivate OnClickListener onClickListener = new OnClickListener() {\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tint id = view.getId();\n\t\t\tswitch (id) {\n\t\t\t// On Click Listener for Set Button\n\t\t\tcase R.id.btn_set:\n\t\t\t\t// Create the ProfileConfig object\n\t\t\t\tif (profileConfigObj.dataCapture.barcode.scanner_input_enabled == ENABLED_STATE.FALSE)\n\t\t\t\t\tToast.makeText(MainActivity.this,\n\t\t\t\t\t\t\t\"Please Enable Barcode to update settings...\",\n\t\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\t\telse\n\t\t\t\t\tupdateProfile();\n\t\t\t\tbreak;\n\t\t\t// On Click Listener for Barcode Button\n\t\t\tcase R.id.btn_barcode:\n\t\t\t\tsetBarcodeStatus();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t  }\n\t\t};\t\t \n\nSo the on click listener would finally look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/button_on_click_defination.jpg)\n\n   >Note:   \n   >We have shown Toast messages wherever necessary to inform user about the operations being performed.\n\n14.As explained earlier, the button Barcode is used for updating the Barcode status using profileConfig object by calling 'setBarcodeStatus' method.\n\nSo the 'setBarcodeStatus()' method can be implemented as:\n\n\t\t:::java\n\t\t// Sets the status of the Barcode (Enable/Disable)\n\t\tpublic void setBarcodeStatus() {\n\t\t // Create the ProfileConfig object\n\t\t profileConfigObj = new ProfileConfig();\n\n\t\t // Get the ProfileConfig from the profile XML\n\t\t EMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\n\t\t // Check the return status of processProfile\n\t\t if (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\n\t\t\tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\treturn;\n\n\t\t }\n\n\t\t if (barcodeStatusButton.getText().toString()\n\t\t\t\t.equalsIgnoreCase(\"Enable Barcode\")) {\n\t\t\t//Barcode is enabled so disable it.\n\t\t\tprofileConfigObj.dataCapture.barcode.scanner_input_enabled = ENABLED_STATE.TRUE;\n\t\t\tbarcodeStatusButton.setText(\"Disable Barcode\");\n\n\t\t } else {\n\t\t\t//Barcode is disabled so enable it.\n\t\t\tprofileConfigObj.dataCapture.barcode.scanner_input_enabled = ENABLED_STATE.FALSE;\n\t\t\tbarcodeStatusButton.setText(\"Enable Barcode\");\n\n\t\t }\n\n\t\t // Call processPrfoile with profile name, SET flag and config data\n\t\t // to update the profile\n\t\t results = profileManager.processProfile(profileName,\n\t\t\t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\n\t\t // Check the return status of processProfile\n\t\t if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\tToast.makeText(MainActivity.this, \"Barcode Status updated\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\n\t\t } else {\n\t\t\tToast.makeText(MainActivity.this, \"Barcode status update failed\",\n\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t }\n\n\t\t}\n\nsetBarcodeStatus() method would look like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/set_barcode_status_method.jpg)\n \n\n15.Finally, we would implement the on click listener for 'Update Profile' by calling 'updateProfile' method. This method would update the status of all the checkboxes (Enable/Disable) that represent the various barcode types.\n\nSo if a particular barcode checkbox is unchecked, the user will not be able to scan that specific type of barcode and vice-versa.\n\nWe will define the 'updateProfile' method as follows:\n\n\t\t:::java\n\t\t// Updates the profile based on user selected attributes\n\t\tpublic void updateProfile() {\n\t\t  String resultString = \"\";\n\t\t  try {\n\n\t\t\t// Create the ProfileConfig object\n\t\t\tprofileConfigObj = new ProfileConfig();\n\n\t\t\t// Get the ProfileConfig from the profile XML\n\t\t\tEMDKResults results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.GET, profileConfigObj);\n\n\t\t\t// Check the return status of processProfile\n\t\t\tif (results.statusCode == EMDKResults.STATUS_CODE.FAILURE) {\n\n\t\t\t\tToast.makeText(MainActivity.this, \"Failed to get Profile\",\n\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\t\treturn;\n\n\t\t\t }\n\n\t\t\t // Set the code128\n\t\t\t if (checkBoxCode128.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.TRUE;\n\n\t\t\t  } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.code128 = ENABLED_STATE.FALSE;\n\t\t\t  }\n\n\t\t\t // set code39\n\t\t\t if (checkBoxCode39.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.code39 = ENABLED_STATE.TRUE;\n\n\t\t\t } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.code39 = ENABLED_STATE.FALSE;\n\t\t\t }\n\n\t\t\t // set EAN8\n\t\t\t if (checkBoxEAN8.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.ean8 = ENABLED_STATE.TRUE;\n\n\t\t\t } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.ean8 = ENABLED_STATE.FALSE;\n\t\t\t }\n\n\t\t\t // set ENA13\n\t\t\t if (checkBoxEAN13.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.ean13 = ENABLED_STATE.TRUE;\n\n\t\t\t } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.ean13 = ENABLED_STATE.FALSE;\n\t\t\t }\n\n\t\t\t // set upca\n\t\t\t if (checkBoxUPCA.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.upca = ENABLED_STATE.TRUE;\n\n\t\t\t } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.upca = ENABLED_STATE.FALSE;\n\t\t\t }\n\n\t\t\t // set upce0\n\t\t\t if (checkBoxUPCE0.isChecked()) {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.upce0 = ENABLED_STATE.TRUE;\n\n\t\t\t } else {\n\n\t\t\t\tprofileConfigObj.dataCapture.barcode.decoders.upce0 = ENABLED_STATE.FALSE;\n\t\t\t }\n\n\t\t\t // Call processPrfoile with profile name, SET flag and config data\n\t\t\t // to update the profile\n\t\t\t results = profileManager.processProfile(profileName,\n\t\t\t\t\tProfileManager.PROFILE_FLAG.SET, profileConfigObj);\n\n\t\t\t // Check the return status of processProfile\n\t\t\t if (results.statusCode == EMDKResults.STATUS_CODE.SUCCESS) {\n\n\t\t\t\tToast.makeText(MainActivity.this,\n\t\t\t\t\t\t\"Profile successfully updated\", Toast.LENGTH_SHORT)\n\t\t\t\t\t\t.show();\n\n\t\t\t } else {\n\t\t\t\tToast.makeText(MainActivity.this, \"Profile update failed\",\n\t\t\t\t\t\tToast.LENGTH_SHORT).show();\n\t\t\t}\n\n\t\t  } catch (Exception ex) {\n\t\t\tresultString = ex.getMessage();\n\t\t\tToast.makeText(MainActivity.this, resultString, Toast.LENGTH_SHORT)\n\t\t\t\t\t.show();\n\t\t  }\n\t\t}\n\nSo the updateProfile method looks like:\n\n![img](images/2.0/modify_profile_settings_images/2.0/update_profile_method.jpg)\n\n16.So now we are done with the coding part. Lets test our application.\n\n17.Connect Motorola Solutions Android device (having the latest EMDK runtime) to the USB port.\n   >Note:   \n   >Make sure the device is in USB debug.\n\n18.Run the application.  \n\n![img](images/2.0/modify_profile_settings_images/2.0/initial_screen.png)\n\n19.Enable/Disable Barcode scanning by pressing Barcode button on top of the screen. \n\n   >Note: If the barcode disabled, you will not be able to scan any type of barcode.\n\n![img](images/2.0/modify_profile_settings_images/2.0/update_barcode_status.png)\n\n20.Choose the specific type of barcode scanning device from the drop down.\n\n![img](images/2.0/modify_profile_settings_images/2.0/drop_down_for_device_type.png)  \n\n21.Now select the desired barcode types from the checkboxes and press the Update Settings button. This will modify the profile settings.\n\n![img](images/2.0/modify_profile_settings_images/2.0/update_settings.png)\n\nNow press trigger button to scan the respective types of barcodes.\n\n22.The scanned data will be populated in the Edit Text field added to the UI.\n   >Note:\n   > Only those typs of barcodes will be scanned that are checked in the checkboxes.\n  \n![img](images/2.0/modify_profile_settings_images/2.0/scan_data.png)  \n\n##Important Programming Tips##\n\n1. It is required to do the following changes in the application's AndroidManifest.xml:  \n  \n   >Note:\n   >Include the permission for EMDK:  \n   >  <uses-permission android:name=\"com.symbol.emdk.permission.EMDK\"/>\n   >  \n   >Use the EMDK library:  \n   >  <uses-library android:name=\"com.symbol.emdk\"/>\n  \n2. When using the \"Barcode\" feature in EMDK Wizard, the specified value for \"Scanner\" is not supported on the device, it will be considered as \"Auto\" during runtime (Ex: BT_LASER1, BT_IMAGER1 and BT_CAMERA1).\n3. Installing the EMDK for Android application without deploying the EMDK runtime on the Motorola Solutions Android  device will fail because of missing shared library on the device. \n4. Use the DataWedge v1.7.12 or higher version to test the ProfileManager.processProfile() for DataWedge profiles.\n\n\n## Download the Source\nThe project source to this tutorial can be [downloaded (Internet Connection Required)](https://s3.amazonaws.com/emdk/Tutorials/EMDK-ModifyBarcodeProfileTutorial.zip)."}];